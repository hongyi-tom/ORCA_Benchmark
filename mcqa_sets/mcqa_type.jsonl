{"old":" Java_com_duckduckgo_sync_crypto_SyncNativeLib_encrypt(\n     );\n \n     \/\/ Release the input arrays\n-    (*env)->ReleaseByteArrayElements(env, encryptedBytes, encryptedBytesElements, JNI_ABORT);\n-    (*env)->ReleaseByteArrayElements(env, rawBytes, rawBytesElements, JNI_COMMIT);\n     (*env)->ReleaseByteArrayElements(env, secretKey, secretKeyElements, JNI_ABORT);\n \n     return result;","new":" Java_com_duckduckgo_sync_crypto_SyncNativeLib_encrypt(\n     );\n \n     \/\/ Release the input arrays\n+    (*env)->ReleaseByteArrayElements(env, encryptedBytes, encryptedBytesElements, JNI_COMMIT);\n+    (*env)->ReleaseByteArrayElements(env, rawBytes, rawBytesElements, JNI_ABORT);\n     (*env)->ReleaseByteArrayElements(env, secretKey, secretKeyElements, JNI_ABORT);\n \n     return result;","review":"if this is the value you want returned, you should not use JNI_ABORT, use commit instead.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" r_ssize r_lgl_sum(r_obj* x, bool na_true) {\n }\n \n r_obj* r_lgl_which(r_obj* x, bool na_propagate) {\n-  if (r_typeof(x) != R_TYPE_logical) {\n-    r_stop_internal(\"Expected logical vector.\");\n   }\n \n   const r_ssize n = r_length(x);","new":" r_ssize r_lgl_sum(r_obj* x, bool na_true) {\n }\n \n r_obj* r_lgl_which(r_obj* x, bool na_propagate) {\n+  const enum r_type type = r_typeof(x);\n+\n+  if (type != R_TYPE_logical) {\n+    r_stop_unexpected_type(type);\n   }\n \n   const r_ssize n = r_length(x);","review":"Could use `r_stop_unexpected_type()`.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" S_aassign_scan(pTHX_ OP* o, bool rhs, int *scalars_p)\n             if (o == effective_top_op)\n                 effective_top_op = next_kid;\n         }\n-        else\n-            if (o == effective_top_op)\n-                effective_top_op = o->op_sibparent;\n         o = o->op_sibparent; \/* try parent's next sibling *\/\n     }\n     o = next_kid;","new":" S_aassign_scan(pTHX_ OP* o, bool rhs, int *scalars_p)\n             if (o == effective_top_op)\n                 effective_top_op = next_kid;\n         }\n+        else if (o == effective_top_op)\n+            effective_top_op = o->op_sibparent;\n         o = o->op_sibparent; \/* try parent's next sibling *\/\n     }\n     o = next_kid;","review":"Would it not be even clearer to also pull the `if` up on the same line as the `else`?","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static int vine_manager_transfer_capacity_available(struct vine_manager *q, stru\n \t\t\/* Provide a substitute file object to describe the peer. *\/\n \t\tif(m->file->type != VINE_MINI_TASK) \n \t\t{\n-\t\t\tvine_file_delete(m->substitute);\n \t\t\tif((peer = vine_file_replica_table_find_worker(q, m->file->cached_name)))\n \t\t\t{\n \t\t\t\tchar *peer_source =  string_format(\"worker:\/\/%s:%d\/%s\", peer->transfer_addr, peer->transfer_port, m->file->cached_name);","new":" static int vine_manager_transfer_capacity_available(struct vine_manager *q, stru\n \t\t\/* Provide a substitute file object to describe the peer. *\/\n \t\tif(m->file->type != VINE_MINI_TASK) \n \t\t{\n \t\t\tif((peer = vine_file_replica_table_find_worker(q, m->file->cached_name)))\n \t\t\t{\n \t\t\t\tchar *peer_source =  string_format(\"worker:\/\/%s:%d\/%s\", peer->transfer_addr, peer->transfer_port, m->file->cached_name);","review":"This might go away with the separate bug fix, but it looks dangerous to delete without setting m->substitute to null.\r\n","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":" static void bucketing_cursor_w_pos_delete(bucketing_cursor_w_pos_t* cursor_pos)\n         list_cursor_destroy(cursor_pos->lc);\n         free(cursor_pos);\n     }\n-    else\n-        warn(D_BUCKETING, \"ignoring command to delete null pointer to bucketing_cursor_w_pos\\n\");\n }\n \n \/* Create a bucketing_bucket_range_t structure","new":" static void bucketing_cursor_w_pos_delete(bucketing_cursor_w_pos_t* cursor_pos)\n         list_cursor_destroy(cursor_pos->lc);\n         free(cursor_pos);\n     }\n }\n \n \/* Create a bucketing_bucket_range_t structure","review":"Remove these warnings.","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":"\n   #endif\n #endif\n \n-#if CYTHON_USE_MODULE_STATE && CYTHON_PEP489_MULTI_PHASE_INIT\n-#error \"Cannot combine CYTHON_USE_MODULE_STATE and CYTHON_PEP489_MULTI_PHASE_INIT\"\n-\/* since PyState_FindModule requires that each module-def is linked to 1 (or 0) modules\n-and multi-phase init allows the same module to be imported many times *\/\n-#endif\n-\n #if !defined(CYTHON_FAST_PYCCALL)\n #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)\n #endif","new":"\n   #endif\n #endif\n \n #if !defined(CYTHON_FAST_PYCCALL)\n #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)\n #endif","review":"Should this really be a compile time error? The fact that is can be imported multiple times does not mean that it will be.","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":" static void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h\n     h2o_iovec_vector_t cookie_values = {NULL};\n     int found_early_data = 0;\n     if (H2O_LIKELY(req->headers.size != 0)) {\n-        const h2o_header_t *h, *h_end;\n-        for (h = req->headers.entries, h_end = h + req->headers.size; h != h_end; ++h) {\n             if (h2o_iovec_is_token(h->name)) {\n                 const h2o_token_t *token = (void *)h->name;\n                 if (token->flags.proxy_should_drop_for_req)","new":" static void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h\n     h2o_iovec_vector_t cookie_values = {NULL};\n     int found_early_data = 0;\n     if (H2O_LIKELY(req->headers.size != 0)) {\n+        for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; h != h_end; ++h) {\n             if (h2o_iovec_is_token(h->name)) {\n                 const h2o_token_t *token = (void *)h->name;\n                 if (token->flags.proxy_should_drop_for_req)","review":"Can we do `for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; ...` here as well?","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static void on_write_complete(h2o_socket_t *sock, const char *err)\n     \/* reset the other buffer *\/\n     h2o_buffer_dispose(&conn->output.buf_in_flight);\n \n-    \/* as request write, unlink the deferred timeout that might have been set by `proceed_req` called above *\/\n     if (h2o_timer_is_linked(&conn->output.defer_timeout))\n         h2o_timer_unlink(&conn->output.defer_timeout);\n-\n #if !H2O_USE_LIBUV\n     if (conn->state == H2O_HTTP2CLIENT_CONN_STATE_OPEN) {\n-        if (conn->output.buf->size != 0 || !h2o_linklist_is_empty(&conn->output.sending_streams))\n-            h2o_socket_notify_write(sock, on_notify_write);\n         return;\n     }\n #endif\n-\n-    \/* write more, if possible *\/\n     do_emit_writereq(conn);\n     close_connection_if_necessary(conn);\n }","new":" static void on_write_complete(h2o_socket_t *sock, const char *err)\n     \/* reset the other buffer *\/\n     h2o_buffer_dispose(&conn->output.buf_in_flight);\n \n+    \/* bail out if nothing can be written *\/\n+    if (conn->output.buf->size == 0 && h2o_linklist_is_empty(&conn->output.sending_streams)) {\n+        assert(!h2o_timer_is_linked(&conn->output.defer_timeout));\n+        close_connection_if_necessary(conn);\n+        return;\n+    }\n+\n+    \/* run next write now instead of relying on the deferred timeout *\/\n     if (h2o_timer_is_linked(&conn->output.defer_timeout))\n         h2o_timer_unlink(&conn->output.defer_timeout);\n #if !H2O_USE_LIBUV\n     if (conn->state == H2O_HTTP2CLIENT_CONN_STATE_OPEN) {\n+        h2o_socket_notify_write(sock, on_notify_write);\n         return;\n     }\n #endif\n     do_emit_writereq(conn);\n     close_connection_if_necessary(conn);\n }","review":"@deweerdt mentioned to me that there's a bare return in L1126 below. \r\n\r\nCould that be a problem if the `if` condition is false on L1124 i.e. could we return with the timer unlinked, while no new timer is linked?","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" h2o_iovec_t h2o_url_normalize_path(h2o_mem_pool_t *pool, const char *path, size_\n     *query_at = SIZE_MAX;\n     *norm_indexes = NULL;\n \n-    if (len == 0 || (len == 1 && path[0] == '\/')) {\n         ret = h2o_iovec_init(\"\/\", 1);\n         return ret;\n     }","new":" h2o_iovec_t h2o_url_normalize_path(h2o_mem_pool_t *pool, const char *path, size_\n     *query_at = SIZE_MAX;\n     *norm_indexes = NULL;\n \n+    if (len == 0) {\n         ret = h2o_iovec_init(\"\/\", 1);\n         return ret;\n     }","review":"Do we need this change?\r\n\r\nI think the code below would run fast when the input is \"\/\". Basically, it tests if `path[0]` is `\/` then skip the for loop. That is exactly the same as the or clause added here.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" int main(int argc, char **argv)\n                 EXPECT_NOT_NULL(conn = s2n_connection_new(S2N_CLIENT));\n                 struct s2n_stuffer *hello_stuffer = &conn->handshake.io;\n                 conn->actual_protocol_version = S2N_TLS12;\n \n                 EXPECT_SUCCESS(s2n_client_hello_send(conn));\n                 EXPECT_SUCCESS(s2n_stuffer_skip_read(hello_stuffer, LENGTH_TO_SESSION_ID));","new":" int main(int argc, char **argv)\n                 EXPECT_NOT_NULL(conn = s2n_connection_new(S2N_CLIENT));\n                 struct s2n_stuffer *hello_stuffer = &conn->handshake.io;\n                 conn->actual_protocol_version = S2N_TLS12;\n+                EXPECT_TRUE(conn->client_protocol_version >= S2N_TLS13);\n \n                 EXPECT_SUCCESS(s2n_client_hello_send(conn));\n                 EXPECT_SUCCESS(s2n_stuffer_skip_read(hello_stuffer, LENGTH_TO_SESSION_ID));","review":"Should you either also set client_protocol_version or verify that it's >=S2N_TLS13, to make sure you're covering this bug?","type_correct":"add_only","type_wrong":["remove_only","modify"]}
{"old":" static bool stylist_validate_requirements(struct map_session_data *sd, int type,\n \t\treturn false;\n \n \tif (entry->id >= 0) {\n-\t\tif (entry->zeny != 0 && pc->payzeny(sd, entry->zeny, LOG_TYPE_OTHER, NULL) != 0) {\n \t\t\treturn false;\n \t\t} else if (entry->itemid != 0) {\n \t\t\tit.nameid = entry->itemid;","new":" static bool stylist_validate_requirements(struct map_session_data *sd, int type,\n \t\treturn false;\n \n \tif (entry->id >= 0) {\n+\t\tif (entry->zeny != 0 && pc->payzeny(sd, entry->zeny, LOG_TYPE_STYLIST, NULL) != 0) {\n \t\t\treturn false;\n \t\t} else if (entry->itemid != 0) {\n \t\t\tit.nameid = entry->itemid;","review":"i not sure, but may be add new log type for stylist?","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" flb_sds_t flb_get_s3_key(const char *format, time_t time, const char *tag,\n         sprintf(seq_index_str, \"%\"PRIu64, seq_index);\n         seq_index_str[seq_index_len] = '\\0';\n         tmp_key = replace_uri_tokens(s3_key, INDEX_STRING, seq_index_str);\n-        if (!tmp_key) {\n             goto error;\n         }\n         if (strlen(tmp_key) > S3_KEY_SIZE) {","new":" flb_sds_t flb_get_s3_key(const char *format, time_t time, const char *tag,\n         sprintf(seq_index_str, \"%\"PRIu64, seq_index);\n         seq_index_str[seq_index_len] = '\\0';\n         tmp_key = replace_uri_tokens(s3_key, INDEX_STRING, seq_index_str);\n+        if (tmp_key == NULL) {\n+            flb_free(seq_index_str);\n             goto error;\n         }\n         if (strlen(tmp_key) > S3_KEY_SIZE) {","review":"I think you're missing a `flb_free(seq_index_str);` there.\r\nOther than that, would you mind change that comparison to `if (tmp_key == NULL) {` instead? I'd really appreciate it.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static void update_retry_metric(struct flb_stackdriver *ctx,\n                                  uint64_t ts,\n                                  int http_status, int ret_code)\n {\n     if (ret_code != FLB_RETRY) {\n         return;\n     }\n \n-    char tmp[32]; \n-    char *name = (char *) flb_output_name(ctx->ins);\n-\n     \/* convert status to string format *\/\n     snprintf(tmp, sizeof(tmp) - 1, \"%i\", http_status);\n     cmt_counter_add(ctx->cmt_retried_records_total,","new":" static void update_retry_metric(struct flb_stackdriver *ctx,\n                                  uint64_t ts,\n                                  int http_status, int ret_code)\n {\n+    char tmp[32]; \n+    char *name = (char *) flb_output_name(ctx->ins);\n+\n     if (ret_code != FLB_RETRY) {\n         return;\n     }\n \n     \/* convert status to string format *\/\n     snprintf(tmp, sizeof(tmp) - 1, \"%i\", http_status);\n     cmt_counter_add(ctx->cmt_retried_records_total,","review":"define vars at the top of the function: https:\/\/github.com\/fluent\/fluent-bit\/blob\/master\/CONTRIBUTING.md#variable-definitions\r\n\r\n","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static void pipeline_config_add_properties(flb_sds_t *buf, struct mk_list *props\n             flb_sds_printf(buf, \"    %s \", kv->key);\n \n             if (is_sensitive_property(kv->key)) {\n-                flb_sds_cat(*buf, \"--redacted--\", strlen(\"--redacted--\"));\n             }\n             else {\n-                flb_sds_cat(*buf, kv->val, strlen(kv->val));\n             }\n \n-            flb_sds_cat(*buf, \"\\n\", 1);\n         }\n     }\n }","new":" static void pipeline_config_add_properties(flb_sds_t *buf, struct mk_list *props\n             flb_sds_printf(buf, \"    %s \", kv->key);\n \n             if (is_sensitive_property(kv->key)) {\n+                flb_sds_cat_safe(*buf, \"--redacted--\", strlen(\"--redacted--\"));\n             }\n             else {\n+                flb_sds_cat_safe(*buf, kv->val, strlen(kv->val));\n             }\n \n+            flb_sds_cat_safe(*buf, \"\\n\", 1);\n         }\n     }\n }","review":"can you use flb_sds_cat_safe() version ?, that version will take care if a realloc happens and the address change. ","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static int flb_proxy_input_cb_exit(void *in_context, struct flb_config *config)\n \n     if (proxy->def->proxy == FLB_PROXY_GOLANG) {\n #ifdef FLB_HAVE_PROXY_GO\n-        proxy_go_output_destroy(ctx);\n #endif\n     }\n ","new":" static int flb_proxy_input_cb_exit(void *in_context, struct flb_config *config)\n \n     if (proxy->def->proxy == FLB_PROXY_GOLANG) {\n #ifdef FLB_HAVE_PROXY_GO\n+        proxy_go_input_destroy(ctx);\n #endif\n     }\n ","review":"Is proxy_go_input_destroy correct here?\r\n\r\n`proxy_go_output_destroy` does not proceed to handle `struct flb_plugin_input_proxy_context ` variable.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" R_API bool r_core_project_save(RCore *core, const char *prj_name) {\n \t\tfree (cwd);\n \t}\n \t\/\/ LEAK : not always in heap free (prj_name);\n \tcore->prj->path = prj_dir;\n \tif (scr_null) {\n \t\tr_config_set_b (core->config, \"scr.null\", true);","new":" R_API bool r_core_project_save(RCore *core, const char *prj_name) {\n \t\tfree (cwd);\n \t}\n \t\/\/ LEAK : not always in heap free (prj_name);\n+\tfree(core->prj->path);\n \tcore->prj->path = prj_dir;\n \tif (scr_null) {\n \t\tr_config_set_b (core->config, \"scr.null\", true);","review":"maybe good to free (core->prj->path) before overwriting the field?","type_correct":"add_only","type_wrong":["remove_only","modify"]}
{"old":" R_API bool r_project_rename(RProject *p, const char *newname) {\n \t\t\treturn true;\n \t\t}\n \t}\n \treturn false;\n }\n ","new":" R_API bool r_project_rename(RProject *p, const char *newname) {\n \t\t\treturn true;\n \t\t}\n \t}\n+\tfree (newprjdir);\n \treturn false;\n }\n ","review":"newprjdir will leak if newname is null","type_correct":"add_only","type_wrong":["remove_only","modify"]}
{"old":" R_API RList *r_type_get_enum(Sdb *TDB, const char *name) {\n }\n \n R_API void r_type_enum_free(RTypeEnum *member) {\n-\tfree (member->name);\n-\tfree (member->val);\n-\tfree (member);\n }\n \n R_API char *r_type_enum_member(Sdb *TDB, const char *name, const char *member, ut64 val) {","new":" R_API RList *r_type_get_enum(Sdb *TDB, const char *name) {\n }\n \n R_API void r_type_enum_free(RTypeEnum *member) {\n+\tif (member) {\n+\t\tfree (member->name);\n+\t\tfree (member->val);\n+\t\tfree (member);\n+\t}\n }\n \n R_API char *r_type_enum_member(Sdb *TDB, const char *name, const char *member, ut64 val) {","review":"All free methods must accept null. Add an if here","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" _PyErr_SetObject(PyThreadState *tstate, PyObject *exception, PyObject *value)\n             Py_DECREF(exc_value);\n         }\n     }\n-    if (value != NULL && PyExceptionInstance_Check(value))\n         tb = PyException_GetTraceback(value);\n     _PyErr_Restore(tstate, Py_NewRef(Py_TYPE(value)), value, tb);\n }","new":" _PyErr_SetObject(PyThreadState *tstate, PyObject *exception, PyObject *value)\n             Py_DECREF(exc_value);\n         }\n     }\n+    assert(value != NULL);\n+    if (PyExceptionInstance_Check(value))\n         tb = PyException_GetTraceback(value);\n     _PyErr_Restore(tstate, Py_NewRef(Py_TYPE(value)), value, tb);\n }","review":"This would crash if `value` is NULL. The if check immediately above suggests that that is possible here.","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":"\n # endif\n #endif\n \n-\/* the deprecated posix apis are not available on xbox *\/\n-#ifdef MS_WINDOWS_GAMES\n-#  define dup _dup\n-#  define dup2 _dup2\n-#endif\n-\n #if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__DragonFly__)\n # define FD_DIR \"\/dev\/fd\"\n #else","new":"\n # endif\n #endif\n \n #if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__DragonFly__)\n # define FD_DIR \"\/dev\/fd\"\n #else","review":"The `_posixsubprocess` extension module shouldn't get built on Windows.","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":" static iree_status_t print_buffer_view(iree_hal_device_t* device,\n   if (iree_status_is_ok(status)) {\n     status = iree_hal_semaphore_create(device, 0ull, &fence_semaphore);\n   }\n-  uint64_t wait_value = 0ull;\n   uint64_t signal_value = 1ull;\n   if (iree_status_is_ok(status)) {\n-    iree_hal_semaphore_list_t wait_semaphores = {\n-        .count = 0,\n-        .semaphores = NULL,\n-        .payload_values = &wait_value,\n-    };\n     iree_hal_semaphore_list_t signal_semaphores = {\n         .count = 1,\n         .semaphores = &fence_semaphore,\n         .payload_values = &signal_value,\n     };\n-    status = iree_hal_device_queue_execute(device, IREE_HAL_QUEUE_AFFINITY_ANY,\n-                                           wait_semaphores, signal_semaphores,\n-                                           1, &command_buffer);\n   }\n   \/\/ TODO(scotttodd): Make this async - pass a wait source to iree_loop_wait_one\n   if (iree_status_is_ok(status)) {","new":" static iree_status_t print_buffer_view(iree_hal_device_t* device,\n   if (iree_status_is_ok(status)) {\n     status = iree_hal_semaphore_create(device, 0ull, &fence_semaphore);\n   }\n   uint64_t signal_value = 1ull;\n   if (iree_status_is_ok(status)) {\n     iree_hal_semaphore_list_t signal_semaphores = {\n         .count = 1,\n         .semaphores = &fence_semaphore,\n         .payload_values = &signal_value,\n     };\n+    status = iree_hal_device_queue_execute(\n+        device, IREE_HAL_QUEUE_AFFINITY_ANY, iree_hal_semaphore_list_empty(),\n+        signal_semaphores, 1, &command_buffer);\n   }\n   \/\/ TODO(scotttodd): Make this async - pass a wait source to iree_loop_wait_one\n   if (iree_status_is_ok(status)) {","review":"you can use `iree_hal_semaphore_list_empty()` for this one","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static iree_status_t iree_hal_cuda_driver_create_internal(\n \n   iree_status_t status =\n       iree_hal_cuda_dynamic_symbols_initialize(host_allocator, &driver->syms);\n-  if (!iree_status_is_ok(status)) {\n-    iree_hal_driver_release((iree_hal_driver_t*)driver);\n-    return status;\n-  }\n-\n   if (iree_status_is_ok(status)) {\n     \/\/ Initialize NCCL if NPROCS is set.\n     if (driver->default_params.nccl_default_count > 0) {","new":" static iree_status_t iree_hal_cuda_driver_create_internal(\n \n   iree_status_t status =\n       iree_hal_cuda_dynamic_symbols_initialize(host_allocator, &driver->syms);\n   if (iree_status_is_ok(status)) {\n     \/\/ Initialize NCCL if NPROCS is set.\n     if (driver->default_params.nccl_default_count > 0) {","review":"you can remove this early return as the status check below handles it","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":" iree_status_t iree_hal_heap_buffer_wrap(\n   IREE_ASSERT_ARGUMENT(out_buffer);\n   IREE_TRACE_ZONE_BEGIN(z0);\n \n-  if (!iree_host_size_has_alignment((uintptr_t)data.data_length,\n                                     IREE_HAL_HEAP_BUFFER_ALIGNMENT)) {\n     IREE_TRACE_ZONE_END(z0);\n     return iree_make_status(\n         IREE_STATUS_OUT_OF_RANGE,\n-        \"imported heap buffer data must be aligned to %d; got %\" PRIhsz,\n-        (int)IREE_HAL_HEAP_BUFFER_ALIGNMENT, data.data_length);\n   }\n \n   iree_allocator_t host_allocator =","new":" iree_status_t iree_hal_heap_buffer_wrap(\n   IREE_ASSERT_ARGUMENT(out_buffer);\n   IREE_TRACE_ZONE_BEGIN(z0);\n \n+  if (!iree_host_size_has_alignment((uintptr_t)data.data,\n                                     IREE_HAL_HEAP_BUFFER_ALIGNMENT)) {\n     IREE_TRACE_ZONE_END(z0);\n     return iree_make_status(\n         IREE_STATUS_OUT_OF_RANGE,\n+        \"imported heap buffer data must be aligned to %d; got %p\",\n+        (int)IREE_HAL_HEAP_BUFFER_ALIGNMENT, data.data);\n   }\n \n   iree_allocator_t host_allocator =","review":"this is incorrect - the base of the buffer pointer is what needs to be aligned, not the size\r\nif the pointers coming back from wgpuBufferGetConstMappedRange are unaligned that's likely to be a problem (but one we could work around in the short term with a flag that disables this check)","type_correct":"modify","type_wrong":["remove_only","add_only"]}
{"old":" static iree_status_t iree_cpu_has_required_target_features(\n     iree_string_view_t required_feature = iree_yaml_node_as_string(item_node);\n     if (iree_string_view_is_empty(required_feature)) continue;\n     int64_t feature_is_supported = 0;\n-    fprintf(stderr, \"Looking up feature by key: %.*s\\n\",\n-            (int)required_feature.size, required_feature.data);\n     IREE_RETURN_IF_ERROR(\n         iree_cpu_lookup_data_by_key(required_feature, &feature_is_supported));\n     if (!feature_is_supported) {","new":" static iree_status_t iree_cpu_has_required_target_features(\n     iree_string_view_t required_feature = iree_yaml_node_as_string(item_node);\n     if (iree_string_view_is_empty(required_feature)) continue;\n     int64_t feature_is_supported = 0;\n     IREE_RETURN_IF_ERROR(\n         iree_cpu_lookup_data_by_key(required_feature, &feature_is_supported));\n     if (!feature_is_supported) {","review":"Probably want to remove this `fprintf`, so it doesn't appear in test \/ CI output for every run?","type_correct":"remove_only","type_wrong":["modify","add_only"]}
{"old":" UA_ServerConfig_clean(UA_ServerConfig *config) {\n #endif\n \n     \/* Logger *\/\n     if(config->logger.clear)\n         config->logger.clear(config->logger.context);\n     config->logger.log = NULL;","new":" UA_ServerConfig_clean(UA_ServerConfig *config) {\n #endif\n \n     \/* Logger *\/\n+    if(config->logging != NULL) {\n+        if((config->logging != &config->logger) &&\n+           (config->logging->clear != NULL)) {\n+            config->logging->clear(config->logging->context);\n+        }\n+        config->logging = NULL;\n+    }\n     if(config->logger.clear)\n         config->logger.clear(config->logger.context);\n     config->logger.log = NULL;","review":"Use `config->pLogger->clear` for the cleanup.\r\nBecause some users will not set the normal config->logger at all.","type_correct":"add_only","type_wrong":["remove_only","modify"]}
