{"old":" r_ssize r_lgl_sum(r_obj* x, bool na_true) {\n }\n \n r_obj* r_lgl_which(r_obj* x, bool na_propagate) {\n-  if (r_typeof(x) != R_TYPE_logical) {\n-    r_stop_internal(\"Expected logical vector.\");\n   }\n \n   const r_ssize n = r_length(x);","new":" r_ssize r_lgl_sum(r_obj* x, bool na_true) {\n }\n \n r_obj* r_lgl_which(r_obj* x, bool na_propagate) {\n+  const enum r_type type = r_typeof(x);\n+\n+  if (type != R_TYPE_logical) {\n+    r_stop_unexpected_type(type);\n   }\n \n   const r_ssize n = r_length(x);","review":"Could use `r_stop_unexpected_type()`.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":" S_aassign_scan(pTHX_ OP* o, bool rhs, int *scalars_p)\n             if (o == effective_top_op)\n                 effective_top_op = next_kid;\n         }\n-        else\n-            if (o == effective_top_op)\n-                effective_top_op = o->op_sibparent;\n         o = o->op_sibparent; \/* try parent's next sibling *\/\n     }\n     o = next_kid;","new":" S_aassign_scan(pTHX_ OP* o, bool rhs, int *scalars_p)\n             if (o == effective_top_op)\n                 effective_top_op = next_kid;\n         }\n+        else if (o == effective_top_op)\n+            effective_top_op = o->op_sibparent;\n         o = o->op_sibparent; \/* try parent's next sibling *\/\n     }\n     o = next_kid;","review":"Would it not be even clearer to also pull the `if` up on the same line as the `else`?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7],"loc_wrong_easy":[[1,2,3],[1,4,5],[8,1,6]],"loc_wrong_hard":[[1,5,6],[1,5,7],[1,6,7]]}
{"old":" static int vine_manager_transfer_capacity_available(struct vine_manager *q, stru\n \t\t\/* Provide a substitute file object to describe the peer. *\/\n \t\tif(m->file->type != VINE_MINI_TASK) \n \t\t{\n-\t\t\tvine_file_delete(m->substitute);\n \t\t\tif((peer = vine_file_replica_table_find_worker(q, m->file->cached_name)))\n \t\t\t{\n \t\t\t\tchar *peer_source =  string_format(\"worker:\/\/%s:%d\/%s\", peer->transfer_addr, peer->transfer_port, m->file->cached_name);","new":" static int vine_manager_transfer_capacity_available(struct vine_manager *q, stru\n \t\t\/* Provide a substitute file object to describe the peer. *\/\n \t\tif(m->file->type != VINE_MINI_TASK) \n \t\t{\n \t\t\tif((peer = vine_file_replica_table_find_worker(q, m->file->cached_name)))\n \t\t\t{\n \t\t\t\tchar *peer_source =  string_format(\"worker:\/\/%s:%d\/%s\", peer->transfer_addr, peer->transfer_port, m->file->cached_name);","review":"This might go away with the separate bug fix, but it looks dangerous to delete without setting m->substitute to null.\r\n","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static void bucketing_cursor_w_pos_delete(bucketing_cursor_w_pos_t* cursor_pos)\n         list_cursor_destroy(cursor_pos->lc);\n         free(cursor_pos);\n     }\n-    else\n-        warn(D_BUCKETING, \"ignoring command to delete null pointer to bucketing_cursor_w_pos\\n\");\n }\n \n \/* Create a bucketing_bucket_range_t structure","new":" static void bucketing_cursor_w_pos_delete(bucketing_cursor_w_pos_t* cursor_pos)\n         list_cursor_destroy(cursor_pos->lc);\n         free(cursor_pos);\n     }\n }\n \n \/* Create a bucketing_bucket_range_t structure","review":"Remove these warnings.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":"\n   #endif\n #endif\n \n-#if CYTHON_USE_MODULE_STATE && CYTHON_PEP489_MULTI_PHASE_INIT\n-#error \"Cannot combine CYTHON_USE_MODULE_STATE and CYTHON_PEP489_MULTI_PHASE_INIT\"\n-\/* since PyState_FindModule requires that each module-def is linked to 1 (or 0) modules\n-and multi-phase init allows the same module to be imported many times *\/\n-#endif\n-\n #if !defined(CYTHON_FAST_PYCCALL)\n #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)\n #endif","new":"\n   #endif\n #endif\n \n #if !defined(CYTHON_FAST_PYCCALL)\n #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)\n #endif","review":"Should this really be a compile time error? The fact that is can be imported multiple times does not mean that it will be.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6,7,8,9,10],"loc_wrong_easy":[[1,2,3,4,5,6],[1,2,3,7,8,9],[1,2,3,10,11,12]],"loc_wrong_hard":[[1,5,6,7,8,9],[1,5,6,7,8,10],[1,5,6,7,9,10]]}
{"old":" static void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h\n     h2o_iovec_vector_t cookie_values = {NULL};\n     int found_early_data = 0;\n     if (H2O_LIKELY(req->headers.size != 0)) {\n-        const h2o_header_t *h, *h_end;\n-        for (h = req->headers.entries, h_end = h + req->headers.size; h != h_end; ++h) {\n             if (h2o_iovec_is_token(h->name)) {\n                 const h2o_token_t *token = (void *)h->name;\n                 if (token->flags.proxy_should_drop_for_req)","new":" static void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h\n     h2o_iovec_vector_t cookie_values = {NULL};\n     int found_early_data = 0;\n     if (H2O_LIKELY(req->headers.size != 0)) {\n+        for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; h != h_end; ++h) {\n             if (h2o_iovec_is_token(h->name)) {\n                 const h2o_token_t *token = (void *)h->name;\n                 if (token->flags.proxy_should_drop_for_req)","review":"Can we do `for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; ...` here as well?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":" static void on_write_complete(h2o_socket_t *sock, const char *err)\n     \/* reset the other buffer *\/\n     h2o_buffer_dispose(&conn->output.buf_in_flight);\n \n-    \/* as request write, unlink the deferred timeout that might have been set by `proceed_req` called above *\/\n     if (h2o_timer_is_linked(&conn->output.defer_timeout))\n         h2o_timer_unlink(&conn->output.defer_timeout);\n-\n #if !H2O_USE_LIBUV\n     if (conn->state == H2O_HTTP2CLIENT_CONN_STATE_OPEN) {\n-        if (conn->output.buf->size != 0 || !h2o_linklist_is_empty(&conn->output.sending_streams))\n-            h2o_socket_notify_write(sock, on_notify_write);\n         return;\n     }\n #endif\n-\n-    \/* write more, if possible *\/\n     do_emit_writereq(conn);\n     close_connection_if_necessary(conn);\n }","new":" static void on_write_complete(h2o_socket_t *sock, const char *err)\n     \/* reset the other buffer *\/\n     h2o_buffer_dispose(&conn->output.buf_in_flight);\n \n+    \/* bail out if nothing can be written *\/\n+    if (conn->output.buf->size == 0 && h2o_linklist_is_empty(&conn->output.sending_streams)) {\n+        assert(!h2o_timer_is_linked(&conn->output.defer_timeout));\n+        close_connection_if_necessary(conn);\n+        return;\n+    }\n+\n+    \/* run next write now instead of relying on the deferred timeout *\/\n     if (h2o_timer_is_linked(&conn->output.defer_timeout))\n         h2o_timer_unlink(&conn->output.defer_timeout);\n #if !H2O_USE_LIBUV\n     if (conn->state == H2O_HTTP2CLIENT_CONN_STATE_OPEN) {\n+        h2o_socket_notify_write(sock, on_notify_write);\n         return;\n     }\n #endif\n     do_emit_writereq(conn);\n     close_connection_if_necessary(conn);\n }","review":"@deweerdt mentioned to me that there's a bare return in L13 below. \r\n\r\nCould that be a problem if the `if` condition is false on L11 i.e. could we return with the timer unlinked, while no new timer is linked?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,8,11,12,16,17],"loc_wrong_easy":[[1,2,3,4,5,6],[1,7,8,9,10,13],[1,11,14,15,18,19]],"loc_wrong_hard":[[1,5,8,11,12,16],[1,5,8,11,12,17],[1,5,8,11,16,17]]}
{"old":" h2o_iovec_t h2o_url_normalize_path(h2o_mem_pool_t *pool, const char *path, size_\n     *query_at = SIZE_MAX;\n     *norm_indexes = NULL;\n \n-    if (len == 0 || (len == 1 && path[0] == '\/')) {\n         ret = h2o_iovec_init(\"\/\", 1);\n         return ret;\n     }","new":" h2o_iovec_t h2o_url_normalize_path(h2o_mem_pool_t *pool, const char *path, size_\n     *query_at = SIZE_MAX;\n     *norm_indexes = NULL;\n \n+    if (len == 0) {\n         ret = h2o_iovec_init(\"\/\", 1);\n         return ret;\n     }","review":"Do we need this change?\r\n\r\nI think the code below would run fast when the input is \"\/\". Basically, it tests if `path[0]` is `\/` then skip the for loop. That is exactly the same as the or clause added here.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int main(int argc, char **argv)\n                 EXPECT_NOT_NULL(conn = s2n_connection_new(S2N_CLIENT));\n                 struct s2n_stuffer *hello_stuffer = &conn->handshake.io;\n                 conn->actual_protocol_version = S2N_TLS12;\n \n                 EXPECT_SUCCESS(s2n_client_hello_send(conn));\n                 EXPECT_SUCCESS(s2n_stuffer_skip_read(hello_stuffer, LENGTH_TO_SESSION_ID));","new":" int main(int argc, char **argv)\n                 EXPECT_NOT_NULL(conn = s2n_connection_new(S2N_CLIENT));\n                 struct s2n_stuffer *hello_stuffer = &conn->handshake.io;\n                 conn->actual_protocol_version = S2N_TLS12;\n+                EXPECT_TRUE(conn->client_protocol_version >= S2N_TLS13);\n \n                 EXPECT_SUCCESS(s2n_client_hello_send(conn));\n                 EXPECT_SUCCESS(s2n_stuffer_skip_read(hello_stuffer, LENGTH_TO_SESSION_ID));","review":"Should you either also set client_protocol_version or verify that it's >=S2N_TLS13, to make sure you're covering this bug?","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" static bool stylist_validate_requirements(struct map_session_data *sd, int type,\n \t\treturn false;\n \n \tif (entry->id >= 0) {\n-\t\tif (entry->zeny != 0 && pc->payzeny(sd, entry->zeny, LOG_TYPE_OTHER, NULL) != 0) {\n \t\t\treturn false;\n \t\t} else if (entry->itemid != 0) {\n \t\t\tit.nameid = entry->itemid;","new":" static bool stylist_validate_requirements(struct map_session_data *sd, int type,\n \t\treturn false;\n \n \tif (entry->id >= 0) {\n+\t\tif (entry->zeny != 0 && pc->payzeny(sd, entry->zeny, LOG_TYPE_STYLIST, NULL) != 0) {\n \t\t\treturn false;\n \t\t} else if (entry->itemid != 0) {\n \t\t\tit.nameid = entry->itemid;","review":"i not sure, but may be add new log type for stylist?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" flb_sds_t flb_get_s3_key(const char *format, time_t time, const char *tag,\n         sprintf(seq_index_str, \"%\"PRIu64, seq_index);\n         seq_index_str[seq_index_len] = '\\0';\n         tmp_key = replace_uri_tokens(s3_key, INDEX_STRING, seq_index_str);\n-        if (!tmp_key) {\n             goto error;\n         }\n         if (strlen(tmp_key) > S3_KEY_SIZE) {","new":" flb_sds_t flb_get_s3_key(const char *format, time_t time, const char *tag,\n         sprintf(seq_index_str, \"%\"PRIu64, seq_index);\n         seq_index_str[seq_index_len] = '\\0';\n         tmp_key = replace_uri_tokens(s3_key, INDEX_STRING, seq_index_str);\n+        if (tmp_key == NULL) {\n+            flb_free(seq_index_str);\n             goto error;\n         }\n         if (strlen(tmp_key) > S3_KEY_SIZE) {","review":"I think you're missing a `flb_free(seq_index_str);` there.\r\nOther than that, would you mind change that comparison to `if (tmp_key == NULL) {` instead? I'd really appreciate it.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static void update_retry_metric(struct flb_stackdriver *ctx,\n                                  uint64_t ts,\n                                  int http_status, int ret_code)\n {\n     if (ret_code != FLB_RETRY) {\n         return;\n     }\n \n-    char tmp[32]; \n-    char *name = (char *) flb_output_name(ctx->ins);\n-\n     \/* convert status to string format *\/\n     snprintf(tmp, sizeof(tmp) - 1, \"%i\", http_status);\n     cmt_counter_add(ctx->cmt_retried_records_total,","new":" static void update_retry_metric(struct flb_stackdriver *ctx,\n                                  uint64_t ts,\n                                  int http_status, int ret_code)\n {\n+    char tmp[32]; \n+    char *name = (char *) flb_output_name(ctx->ins);\n+\n     if (ret_code != FLB_RETRY) {\n         return;\n     }\n \n     \/* convert status to string format *\/\n     snprintf(tmp, sizeof(tmp) - 1, \"%i\", http_status);\n     cmt_counter_add(ctx->cmt_retried_records_total,","review":"define vars at the top of the function: https:\/\/github.com\/fluent\/fluent-bit\/blob\/master\/CONTRIBUTING.md#variable-definitions\r\n\r\n","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[9,10,11],"loc_wrong_easy":[[1,2,3],[4,5,6],[8,12,7]],"loc_wrong_hard":[[1,10,9],[1,11,9],[1,10,11]]}
{"old":" static void pipeline_config_add_properties(flb_sds_t *buf, struct mk_list *props\n             flb_sds_printf(buf, \"    %s \", kv->key);\n \n             if (is_sensitive_property(kv->key)) {\n-                flb_sds_cat(*buf, \"--redacted--\", strlen(\"--redacted--\"));\n             }\n             else {\n-                flb_sds_cat(*buf, kv->val, strlen(kv->val));\n             }\n \n-            flb_sds_cat(*buf, \"\\n\", 1);\n         }\n     }\n }","new":" static void pipeline_config_add_properties(flb_sds_t *buf, struct mk_list *props\n             flb_sds_printf(buf, \"    %s \", kv->key);\n \n             if (is_sensitive_property(kv->key)) {\n+                flb_sds_cat_safe(*buf, \"--redacted--\", strlen(\"--redacted--\"));\n             }\n             else {\n+                flb_sds_cat_safe(*buf, kv->val, strlen(kv->val));\n             }\n \n+            flb_sds_cat_safe(*buf, \"\\n\", 1);\n         }\n     }\n }","review":"can you use flb_sds_cat_safe() version ?, that version will take care if a realloc happens and the address change. ","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[8,11,5],"loc_wrong_easy":[[1,2,3],[4,6,7],[9,10,12]],"loc_wrong_hard":[[8,1,5],[1,11,5],[8,1,11]]}
{"old":" static int flb_proxy_input_cb_exit(void *in_context, struct flb_config *config)\n \n     if (proxy->def->proxy == FLB_PROXY_GOLANG) {\n #ifdef FLB_HAVE_PROXY_GO\n-        proxy_go_output_destroy(ctx);\n #endif\n     }\n ","new":" static int flb_proxy_input_cb_exit(void *in_context, struct flb_config *config)\n \n     if (proxy->def->proxy == FLB_PROXY_GOLANG) {\n #ifdef FLB_HAVE_PROXY_GO\n+        proxy_go_input_destroy(ctx);\n #endif\n     }\n ","review":"Is proxy_go_input_destroy correct here?\r\n\r\n`proxy_go_output_destroy` does not proceed to handle `struct flb_plugin_input_proxy_context ` variable.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" R_API bool r_core_project_save(RCore *core, const char *prj_name) {\n \t\tfree (cwd);\n \t}\n \t\/\/ LEAK : not always in heap free (prj_name);\n \tcore->prj->path = prj_dir;\n \tif (scr_null) {\n \t\tr_config_set_b (core->config, \"scr.null\", true);","new":" R_API bool r_core_project_save(RCore *core, const char *prj_name) {\n \t\tfree (cwd);\n \t}\n \t\/\/ LEAK : not always in heap free (prj_name);\n+\tfree(core->prj->path);\n \tcore->prj->path = prj_dir;\n \tif (scr_null) {\n \t\tr_config_set_b (core->config, \"scr.null\", true);","review":"maybe good to free (core->prj->path) before overwriting the field?","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" R_API bool r_project_rename(RProject *p, const char *newname) {\n \t\t\treturn true;\n \t\t}\n \t}\n \treturn false;\n }\n ","new":" R_API bool r_project_rename(RProject *p, const char *newname) {\n \t\t\treturn true;\n \t\t}\n \t}\n+\tfree (newprjdir);\n \treturn false;\n }\n ","review":"newprjdir will leak if newname is null","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" R_API RList *r_type_get_enum(Sdb *TDB, const char *name) {\n }\n \n R_API void r_type_enum_free(RTypeEnum *member) {\n-\tfree (member->name);\n-\tfree (member->val);\n-\tfree (member);\n }\n \n R_API char *r_type_enum_member(Sdb *TDB, const char *name, const char *member, ut64 val) {","new":" R_API RList *r_type_get_enum(Sdb *TDB, const char *name) {\n }\n \n R_API void r_type_enum_free(RTypeEnum *member) {\n+\tif (member) {\n+\t\tfree (member->name);\n+\t\tfree (member->val);\n+\t\tfree (member);\n+\t}\n }\n \n R_API char *r_type_enum_member(Sdb *TDB, const char *name, const char *member, ut64 val) {","review":"All free methods must accept null. Add an if here","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7],"loc_wrong_easy":[[1,2,3],[1,4,5],[8,1,6]],"loc_wrong_hard":[[1,5,6],[1,5,7],[1,6,7]]}
{"old":" _PyErr_SetObject(PyThreadState *tstate, PyObject *exception, PyObject *value)\n             Py_DECREF(exc_value);\n         }\n     }\n-    if (value != NULL && PyExceptionInstance_Check(value))\n         tb = PyException_GetTraceback(value);\n     _PyErr_Restore(tstate, Py_NewRef(Py_TYPE(value)), value, tb);\n }","new":" _PyErr_SetObject(PyThreadState *tstate, PyObject *exception, PyObject *value)\n             Py_DECREF(exc_value);\n         }\n     }\n+    assert(value != NULL);\n+    if (PyExceptionInstance_Check(value))\n         tb = PyException_GetTraceback(value);\n     _PyErr_Restore(tstate, Py_NewRef(Py_TYPE(value)), value, tb);\n }","review":"This would crash if `value` is NULL. The if check immediately above suggests that that is possible here.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"\n # endif\n #endif\n \n-\/* the deprecated posix apis are not available on xbox *\/\n-#ifdef MS_WINDOWS_GAMES\n-#  define dup _dup\n-#  define dup2 _dup2\n-#endif\n-\n #if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__DragonFly__)\n # define FD_DIR \"\/dev\/fd\"\n #else","new":"\n # endif\n #endif\n \n #if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__DragonFly__)\n # define FD_DIR \"\/dev\/fd\"\n #else","review":"The `_posixsubprocess` extension module shouldn't get built on Windows.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6,7,8,9,10],"loc_wrong_easy":[[1,2,3,4,5,6],[1,2,3,7,8,9],[1,2,3,10,11,12]],"loc_wrong_hard":[[1,5,6,7,8,9],[1,5,6,7,8,10],[1,5,6,7,9,10]]}
{"old":" static iree_status_t print_buffer_view(iree_hal_device_t* device,\n   if (iree_status_is_ok(status)) {\n     status = iree_hal_semaphore_create(device, 0ull, &fence_semaphore);\n   }\n-  uint64_t wait_value = 0ull;\n   uint64_t signal_value = 1ull;\n   if (iree_status_is_ok(status)) {\n-    iree_hal_semaphore_list_t wait_semaphores = {\n-        .count = 0,\n-        .semaphores = NULL,\n-        .payload_values = &wait_value,\n-    };\n     iree_hal_semaphore_list_t signal_semaphores = {\n         .count = 1,\n         .semaphores = &fence_semaphore,\n         .payload_values = &signal_value,\n     };\n-    status = iree_hal_device_queue_execute(device, IREE_HAL_QUEUE_AFFINITY_ANY,\n-                                           wait_semaphores, signal_semaphores,\n-                                           1, &command_buffer);\n   }\n   \/\/ TODO(scotttodd): Make this async - pass a wait source to iree_loop_wait_one\n   if (iree_status_is_ok(status)) {","new":" static iree_status_t print_buffer_view(iree_hal_device_t* device,\n   if (iree_status_is_ok(status)) {\n     status = iree_hal_semaphore_create(device, 0ull, &fence_semaphore);\n   }\n   uint64_t signal_value = 1ull;\n   if (iree_status_is_ok(status)) {\n     iree_hal_semaphore_list_t signal_semaphores = {\n         .count = 1,\n         .semaphores = &fence_semaphore,\n         .payload_values = &signal_value,\n     };\n+    status = iree_hal_device_queue_execute(\n+        device, IREE_HAL_QUEUE_AFFINITY_ANY, iree_hal_semaphore_list_empty(),\n+        signal_semaphores, 1, &command_buffer);\n   }\n   \/\/ TODO(scotttodd): Make this async - pass a wait source to iree_loop_wait_one\n   if (iree_status_is_ok(status)) {","review":"you can use `iree_hal_semaphore_list_empty()` for this one","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,8,9,10,11,12,18,19,20],"loc_wrong_easy":[[1,2,3,4,5,6,7,8,9],[1,2,3,4,10,11,12,13,14],[1,2,3,4,15,16,17,18,19]],"loc_wrong_hard":[[1,5,8,9,10,11,12,18,19],[1,5,8,9,10,11,12,18,20],[1,5,8,9,10,11,12,19,20]]}
{"old":" static iree_status_t iree_hal_cuda_driver_create_internal(\n \n   iree_status_t status =\n       iree_hal_cuda_dynamic_symbols_initialize(host_allocator, &driver->syms);\n-  if (!iree_status_is_ok(status)) {\n-    iree_hal_driver_release((iree_hal_driver_t*)driver);\n-    return status;\n-  }\n-\n   if (iree_status_is_ok(status)) {\n     \/\/ Initialize NCCL if NPROCS is set.\n     if (driver->default_params.nccl_default_count > 0) {","new":" static iree_status_t iree_hal_cuda_driver_create_internal(\n \n   iree_status_t status =\n       iree_hal_cuda_dynamic_symbols_initialize(host_allocator, &driver->syms);\n   if (iree_status_is_ok(status)) {\n     \/\/ Initialize NCCL if NPROCS is set.\n     if (driver->default_params.nccl_default_count > 0) {","review":"you can remove this early return as the status check below handles it","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5],[1,2,6,7,10],[1,2,8,9,11]],"loc_wrong_hard":[[1,5,6,7,8],[1,5,6,7,9],[1,5,6,8,9]]}
{"old":" iree_status_t iree_hal_heap_buffer_wrap(\n   IREE_ASSERT_ARGUMENT(out_buffer);\n   IREE_TRACE_ZONE_BEGIN(z0);\n \n-  if (!iree_host_size_has_alignment((uintptr_t)data.data_length,\n                                     IREE_HAL_HEAP_BUFFER_ALIGNMENT)) {\n     IREE_TRACE_ZONE_END(z0);\n     return iree_make_status(\n         IREE_STATUS_OUT_OF_RANGE,\n-        \"imported heap buffer data must be aligned to %d; got %\" PRIhsz,\n-        (int)IREE_HAL_HEAP_BUFFER_ALIGNMENT, data.data_length);\n   }\n \n   iree_allocator_t host_allocator =","new":" iree_status_t iree_hal_heap_buffer_wrap(\n   IREE_ASSERT_ARGUMENT(out_buffer);\n   IREE_TRACE_ZONE_BEGIN(z0);\n \n+  if (!iree_host_size_has_alignment((uintptr_t)data.data,\n                                     IREE_HAL_HEAP_BUFFER_ALIGNMENT)) {\n     IREE_TRACE_ZONE_END(z0);\n     return iree_make_status(\n         IREE_STATUS_OUT_OF_RANGE,\n+        \"imported heap buffer data must be aligned to %d; got %p\",\n+        (int)IREE_HAL_HEAP_BUFFER_ALIGNMENT, data.data);\n   }\n \n   iree_allocator_t host_allocator =","review":"this is incorrect - the base of the buffer pointer is what needs to be aligned, not the size\r\nif the pointers coming back from wgpuBufferGetConstMappedRange are unaligned that's likely to be a problem (but one we could work around in the short term with a flag that disables this check)","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[10,11,5],"loc_wrong_easy":[[1,2,3],[4,6,7],[8,9,12]],"loc_wrong_hard":[[1,10,5],[1,11,5],[1,10,11]]}
{"old":" static iree_status_t iree_cpu_has_required_target_features(\n     iree_string_view_t required_feature = iree_yaml_node_as_string(item_node);\n     if (iree_string_view_is_empty(required_feature)) continue;\n     int64_t feature_is_supported = 0;\n-    fprintf(stderr, \"Looking up feature by key: %.*s\\n\",\n-            (int)required_feature.size, required_feature.data);\n     IREE_RETURN_IF_ERROR(\n         iree_cpu_lookup_data_by_key(required_feature, &feature_is_supported));\n     if (!feature_is_supported) {","new":" static iree_status_t iree_cpu_has_required_target_features(\n     iree_string_view_t required_feature = iree_yaml_node_as_string(item_node);\n     if (iree_string_view_is_empty(required_feature)) continue;\n     int64_t feature_is_supported = 0;\n     IREE_RETURN_IF_ERROR(\n         iree_cpu_lookup_data_by_key(required_feature, &feature_is_supported));\n     if (!feature_is_supported) {","review":"Probably want to remove this `fprintf`, so it doesn't appear in test \/ CI output for every run?","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":" UA_ServerConfig_clean(UA_ServerConfig *config) {\n #endif\n \n     \/* Logger *\/\n     if(config->logger.clear)\n         config->logger.clear(config->logger.context);\n     config->logger.log = NULL;","new":" UA_ServerConfig_clean(UA_ServerConfig *config) {\n #endif\n \n     \/* Logger *\/\n+    if(config->logging != NULL) {\n+        if((config->logging != &config->logger) &&\n+           (config->logging->clear != NULL)) {\n+            config->logging->clear(config->logging->context);\n+        }\n+        config->logging = NULL;\n+    }\n     if(config->logger.clear)\n         config->logger.clear(config->logger.context);\n     config->logger.log = NULL;","review":"Use `config->pLogger->clear` for the cleanup.\r\nBecause some users will not set the normal config->logger at all.","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" int s2n_set_cipher_as_client(struct s2n_connection *conn, uint8_t wire[S2N_TLS_C\n \n static int s2n_wire_ciphers_contain(const uint8_t *match, const uint8_t *wire, uint32_t count, uint32_t cipher_suite_len)\n {\n-    for (size_t i = 0; i < count; i++) {\n         const uint8_t *theirs = wire + (i * cipher_suite_len) + (cipher_suite_len - S2N_TLS_CIPHER_SUITE_LEN);\n \n         if (!memcmp(match, theirs, S2N_TLS_CIPHER_SUITE_LEN)) {","new":" int s2n_set_cipher_as_client(struct s2n_connection *conn, uint8_t wire[S2N_TLS_C\n \n static int s2n_wire_ciphers_contain(const uint8_t *match, const uint8_t *wire, uint32_t count, uint32_t cipher_suite_len)\n {\n+    for (size_t i = 0; i < (size_t) count; i++) {\n         const uint8_t *theirs = wire + (i * cipher_suite_len) + (cipher_suite_len - S2N_TLS_CIPHER_SUITE_LEN);\n \n         if (!memcmp(match, theirs, S2N_TLS_CIPHER_SUITE_LEN)) {","review":"This should probably be a `uint32_t`. I'm concerned about the `i < count` comparison: before the change the types matched, now they don't. \r\n\r\nIs this broken by `-Wsign-compare-check`? What line does the compiler warn about if so?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int s2n_set_cipher_as_client(struct s2n_connection *conn, uint8_t wire[S2N_TLS_C\n \n static int s2n_wire_ciphers_contain(const uint8_t *match, const uint8_t *wire, uint32_t count, uint32_t cipher_suite_len)\n {\n-    for (size_t i = 0; i < (size_t) count; i++) {\n         const uint8_t *theirs = wire + (i * cipher_suite_len) + (cipher_suite_len - S2N_TLS_CIPHER_SUITE_LEN);\n \n         if (!memcmp(match, theirs, S2N_TLS_CIPHER_SUITE_LEN)) {","new":" int s2n_set_cipher_as_client(struct s2n_connection *conn, uint8_t wire[S2N_TLS_C\n \n static int s2n_wire_ciphers_contain(const uint8_t *match, const uint8_t *wire, uint32_t count, uint32_t cipher_suite_len)\n {\n+    for (size_t i = 0; i < count; i++) {\n         const uint8_t *theirs = wire + (i * cipher_suite_len) + (cipher_suite_len - S2N_TLS_CIPHER_SUITE_LEN);\n \n         if (!memcmp(match, theirs, S2N_TLS_CIPHER_SUITE_LEN)) {","review":"Doesn't the sign-compare check only apply if the signs are different? It doesn't seem like this cast is needed, but I could be wrong. If there is a reason to make this cast, wouldn't a lot of the other for loops also have to be updated?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int main(int argc, char **argv)\n             }\n \n             uint16_t prime = 257;\n-            for (uint32_t i = 0; i < (size_t) 0xFFFFFF - prime; i += prime) {\n                 EXPECT_SUCCESS(s2n_stuffer_write_network_order(&stuffer, i, byte_length));\n                 EXPECT_SUCCESS(s2n_stuffer_read_uint24(&stuffer, &actual_value));\n                 EXPECT_EQUAL(i, actual_value);","new":" int main(int argc, char **argv)\n             }\n \n             uint16_t prime = 257;\n+            for (uint32_t i = 0; i < (uint32_t) 0xFFFFFF - prime; i += prime) {\n                 EXPECT_SUCCESS(s2n_stuffer_write_network_order(&stuffer, i, byte_length));\n                 EXPECT_SUCCESS(s2n_stuffer_read_uint24(&stuffer, &actual_value));\n                 EXPECT_EQUAL(i, actual_value);","review":"Should this be `(uint32_t) 0xFF`...?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int main(int argc, char **argv)\n         EXPECT_BYTEARRAY_EQUAL(client_hello->extensions.raw.data, client_extensions, client_extensions_len);\n \n         \/* Verify s2n_client_hello_get_extensions_length correct *\/\n-        EXPECT_EQUAL(s2n_client_hello_get_extensions_length(client_hello), (ssize_t) client_extensions_len);\n \n         \/* Verify s2n_client_hello_get_extensions correct *\/\n         uint8_t *extensions_out;\n \n         \/* Verify s2n_client_hello_get_extensions retrieves the full cipher_suites when its len <= max_len *\/\n         EXPECT_TRUE(client_hello->extensions.raw.size < S2N_LARGE_RECORD_LENGTH);\n         EXPECT_NOT_NULL(extensions_out = malloc(S2N_LARGE_RECORD_LENGTH));\n-        EXPECT_EQUAL((ssize_t) client_extensions_len, s2n_client_hello_get_extensions(client_hello, extensions_out, S2N_LARGE_RECORD_LENGTH));\n         EXPECT_BYTEARRAY_EQUAL(extensions_out, client_extensions, client_extensions_len);\n         free(extensions_out);\n         extensions_out = NULL;","new":" int main(int argc, char **argv)\n         EXPECT_BYTEARRAY_EQUAL(client_hello->extensions.raw.data, client_extensions, client_extensions_len);\n \n         \/* Verify s2n_client_hello_get_extensions_length correct *\/\n+        EXPECT_EQUAL(s2n_client_hello_get_extensions_length(client_hello), client_extensions_len);\n \n         \/* Verify s2n_client_hello_get_extensions correct *\/\n         uint8_t *extensions_out;\n \n         \/* Verify s2n_client_hello_get_extensions retrieves the full cipher_suites when its len <= max_len *\/\n         EXPECT_TRUE(client_hello->extensions.raw.size < S2N_LARGE_RECORD_LENGTH);\n         EXPECT_NOT_NULL(extensions_out = malloc(S2N_LARGE_RECORD_LENGTH));\n+        EXPECT_EQUAL(client_extensions_len, s2n_client_hello_get_extensions(client_hello, extensions_out, S2N_LARGE_RECORD_LENGTH));\n         EXPECT_BYTEARRAY_EQUAL(extensions_out, client_extensions, client_extensions_len);\n         free(extensions_out);\n         extensions_out = NULL;","review":"Is the cast here required? Looks like you changed `client_extensions_len` to be an `ssize_t` and `s2n_client_hello_get_extensions_length` returns an `ssize_t`. Same on line 13. ","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[13,5],"loc_wrong_easy":[[1,2],[3,4],[6,7]],"loc_wrong_hard":[[1,5],[1,13],[2,5]]}
{"old":" static int s2n_parse_x509_extension(struct s2n_cert *cert, const uint8_t *oid,\n             \/* ASN1_STRING_length() returns the length of the content of `asn1_str`.\n             * Ref: https:\/\/www.openssl.org\/docs\/man1.1.0\/man3\/ASN1_STRING_length.html.\n             *\/\n-            uint32_t len = ASN1_STRING_length(asn1_str);\n             if (ext_value != NULL) {\n                 POSIX_ENSURE(*ext_value_len >= len, S2N_ERR_INSUFFICIENT_MEM_SIZE);\n                 \/* ASN1_STRING_data() returns an internal pointer to the data. ","new":" static int s2n_parse_x509_extension(struct s2n_cert *cert, const uint8_t *oid,\n             \/* ASN1_STRING_length() returns the length of the content of `asn1_str`.\n             * Ref: https:\/\/www.openssl.org\/docs\/man1.1.0\/man3\/ASN1_STRING_length.html.\n             *\/\n+            int len = ASN1_STRING_length(asn1_str);\n             if (ext_value != NULL) {\n                 POSIX_ENSURE(*ext_value_len >= len, S2N_ERR_INSUFFICIENT_MEM_SIZE);\n                 \/* ASN1_STRING_data() returns an internal pointer to the data. ","review":"This returns a `int` so it's best to keep it signed, or at least make sure it's non-negative before casting it.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static int s2n_rsa_encrypt(const struct s2n_pkey *pub, struct s2n_blob *in, stru\n     \/* Safety: RSA_public_encrypt does not mutate the key *\/\n     int r = RSA_public_encrypt(in->size, (unsigned char *) in->data, (unsigned char *) out->data,\n             s2n_unsafe_rsa_get_non_const(pub_key), RSA_PKCS1_PADDING);\n-    POSIX_ENSURE((int64_t) r == out->size, S2N_ERR_SIZE_MISMATCH);\n \n     return 0;\n }","new":" static int s2n_rsa_encrypt(const struct s2n_pkey *pub, struct s2n_blob *in, stru\n     \/* Safety: RSA_public_encrypt does not mutate the key *\/\n     int r = RSA_public_encrypt(in->size, (unsigned char *) in->data, (unsigned char *) out->data,\n             s2n_unsafe_rsa_get_non_const(pub_key), RSA_PKCS1_PADDING);\n+    POSIX_ENSURE((int64_t) r == (int64_t) out->size, S2N_ERR_SIZE_MISMATCH);\n \n     return 0;\n }","review":"Sorry if I'm missing something here, but if `r` is cast to `int64` but `out->size` is unsigned, won't `r` still be cast to unsigned when comparing? And shouldn't the compiler still complain about this with the sign-compare check?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"\n \/* The valid_public_key in the corpus directory was generated by taking the first public\n  * key (count = 0) from kyber_r3.kat and prepending KYBER_512_R3_PUBLIC_KEY_BYTES as two\n  * hex-encoded bytes. This is how we would expect it to appear on the wire. *\/\n-static struct s2n_kem_params kem_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = true };\n \n int s2n_fuzz_test(const uint8_t *buf, size_t len) {\n-    POSIX_GUARD(s2n_kem_recv_public_key_fuzz_test(buf, len, &kem_params));\n     return S2N_SUCCESS;\n }\n ","new":"\n \/* The valid_public_key in the corpus directory was generated by taking the first public\n  * key (count = 0) from kyber_r3.kat and prepending KYBER_512_R3_PUBLIC_KEY_BYTES as two\n  * hex-encoded bytes. This is how we would expect it to appear on the wire. *\/\n+static struct s2n_kem_params kyber_r3_draft0_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = true };\n+static struct s2n_kem_params kyber_r3_draft5_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = false };\n \n int s2n_fuzz_test(const uint8_t *buf, size_t len) {\n+    POSIX_GUARD(s2n_kem_recv_public_key_fuzz_test(buf, len, &kyber_r3_draft0_params));\n+    POSIX_GUARD(s2n_kem_recv_public_key_fuzz_test(buf, len, &kyber_r3_draft5_params));\n     return S2N_SUCCESS;\n }\n ","review":"For all of the fuzz tests, does it make sense to have versions for `len_prefixed` both `true` and `false` ?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[8,5],"loc_wrong_easy":[[1,2],[3,4],[6,7]],"loc_wrong_hard":[[1,5],[8,1],[2,5]]}
{"old":"\n  * A valid ciphertext to provide to s2n_kem_recv_ciphertext (as it would have appeared on\n  * the wire) was generated by taking the corresponding KAT ciphertext (count = 0) and\n  * prepending KYBER_512_R3_CIPHERTEXT_BYTES as two hex-encoded bytes. *\/\n-static struct s2n_kem_params kem_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = true };\n \n int s2n_fuzz_init(int *argc, char **argv[])\n {\n-    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test_init(KAT_FILE_NAME, &kem_params));\n     return S2N_SUCCESS;\n }\n \n int s2n_fuzz_test(const uint8_t *buf, size_t len)\n {\n-    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test(buf, len, &kem_params));\n     return S2N_SUCCESS;\n }\n \n static void s2n_fuzz_cleanup()\n {\n-    s2n_kem_free(&kem_params);\n }\n \n S2N_FUZZ_TARGET(s2n_fuzz_init, s2n_fuzz_test, s2n_fuzz_cleanup)","new":"\n  * A valid ciphertext to provide to s2n_kem_recv_ciphertext (as it would have appeared on\n  * the wire) was generated by taking the corresponding KAT ciphertext (count = 0) and\n  * prepending KYBER_512_R3_CIPHERTEXT_BYTES as two hex-encoded bytes. *\/\n+static struct s2n_kem_params kyber_r3_draft0_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = true };\n+static struct s2n_kem_params kyber_r3_draft5_params = { .kem = &s2n_kyber_512_r3, .len_prefixed = false };\n \n int s2n_fuzz_init(int *argc, char **argv[])\n {\n+    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test_init(KAT_FILE_NAME, &kyber_r3_draft0_params));\n+    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test_init(KAT_FILE_NAME, &kyber_r3_draft5_params));\n     return S2N_SUCCESS;\n }\n \n int s2n_fuzz_test(const uint8_t *buf, size_t len)\n {\n+    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test(buf, len, &kyber_r3_draft0_params));\n+    POSIX_GUARD(s2n_kem_recv_ciphertext_fuzz_test(buf, len, &kyber_r3_draft5_params));\n     return S2N_SUCCESS;\n }\n \n static void s2n_fuzz_cleanup()\n {\n+    s2n_kem_free(&kyber_r3_draft0_params);\n+    s2n_kem_free(&kyber_r3_draft5_params);\n }\n \n S2N_FUZZ_TARGET(s2n_fuzz_init, s2n_fuzz_test, s2n_fuzz_cleanup)\n+","review":"This test is Kyber specific and TLS version agnostic. So, I think it probably makes sense to test both `true` and `false`.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[9,21,5,15],"loc_wrong_easy":[[1,2,3,4],[8,10,6,7],[11,12,13,14]],"loc_wrong_hard":[[1,5,9,15],[1,21,5,9],[1,21,5,15]]}
{"old":" bool s2n_kem_preferences_includes_tls13_kem_group(const struct s2n_kem_preferenc\n     return false;\n }\n \n-\/* Whether the client should include the length prefix in the PQ TLS 1.3 KEM KeyShares that it sends. Earlier drafts of\n- * the PQ TLS 1.3 standard required length prefixing, and later drafts removed this length prefix. To not break\n  * backwards compatibility, we check what revision of the draft standard is configured to determine whether to send it. *\/\n-bool s2n_tls13_client_prefers_hybrid_kem_length_prefix(const struct s2n_kem_preferences *kem_pref)\n {\n     return kem_pref && (kem_pref->tls13_pq_hybrid_draft_revision == 0);\n }","new":" bool s2n_kem_preferences_includes_tls13_kem_group(const struct s2n_kem_preferenc\n     return false;\n }\n \n+\/* Whether the client must include the length prefix in the PQ TLS 1.3 KEM KeyShares that it sends. Draft 0 of\n+ * the PQ TLS 1.3 standard required length prefixing, and drafts 1-5 removed this length prefix. To not break\n  * backwards compatibility, we check what revision of the draft standard is configured to determine whether to send it. *\/\n+bool s2n_tls13_client_must_use_hybrid_kem_length_prefix(const struct s2n_kem_preferences *kem_pref)\n {\n     return kem_pref && (kem_pref->tls13_pq_hybrid_draft_revision == 0);\n }","review":"Suggest being specific about referencing the draft versions; `... draft 0 ...` and `... drafts 1-5 ...`. \"Earlier drafts\" and \"later drafts\" don't answer the possible question of why we're checking explicitly for `kem_pref->tls13_pq_hybrid_draft_revision == 0`.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[8,5,6],"loc_wrong_easy":[[1,2,3],[1,4,5],[1,6,7]],"loc_wrong_hard":[[1,5,6],[8,1,5],[8,1,6]]}
{"old":" static struct flb_config_map config_map[] = {\n     {\n       FLB_CONFIG_MAP_BOOL, \"use_ansi\", \"false\",\n       0, FLB_TRUE, offsetof(struct winevtlog_config, ignore_missing_channels),\n-      \"Use ANSI encoding on eventlog messages\"\n     },\n \n     \/* EOF *\/","new":" static struct flb_config_map config_map[] = {\n     {\n       FLB_CONFIG_MAP_BOOL, \"use_ansi\", \"false\",\n       0, FLB_TRUE, offsetof(struct winevtlog_config, ignore_missing_channels),\n+      \"Whether to ignore channels missing in eventlog\"\n     },\n \n     \/* EOF *\/","review":"Could you use the actual description and parameter here like as `ignore_missing_channels` or similar?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" char *flb_tail_file_name(struct flb_tail_file *file)\n             break;\n         }\n     }\n-    flb_free(file_entries);\n #endif\n     return buf;\n }","new":" char *flb_tail_file_name(struct flb_tail_file *file)\n             break;\n         }\n     }\n+    free(file_entries);\n #endif\n     return buf;\n }","review":"This should be a `free` call because the system uses `malloc` to reserve that memory whereas fluent-bit could be using its own allocator and that could cause an issue.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" void flb_ml_parser_destroy_all(struct mk_list *list)\n     struct mk_list *head;\n     struct flb_ml_parser *parser;\n \n-    \/* Ensure list is initialized *\/\n-    if (list->next == NULL) {\n-        return;\n-    }\n-\n     mk_list_foreach_safe(head, tmp, list) {\n         parser = mk_list_entry(head, struct flb_ml_parser, _head);\n         flb_ml_parser_destroy(parser);","new":" void flb_ml_parser_destroy_all(struct mk_list *list)\n     struct mk_list *head;\n     struct flb_ml_parser *parser;\n \n     mk_list_foreach_safe(head, tmp, list) {\n         parser = mk_list_entry(head, struct flb_ml_parser, _head);\n         flb_ml_parser_destroy(parser);","review":"I think the check should not be here, if there is a mk_list_init() in place the check should not be needed.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5],[1,2,6,7,10],[1,2,8,9,11]],"loc_wrong_hard":[[1,5,6,7,8],[1,5,6,7,9],[1,5,6,8,9]]}
{"old":" static struct flb_config_map config_map[] = {\n      \"Set the parser\"\n     },\n     {\n-      FLB_CONFIG_MAP_SIZE, \"buffer_rcv_size\", (char *)NULL,\n-      0, FLB_TRUE, offsetof(struct flb_syslog, buffer_rcv_size),\n       \"Set the socket receiving buffer size\"\n     },\n     \/* EOF *\/","new":" static struct flb_config_map config_map[] = {\n      \"Set the parser\"\n     },\n     {\n+      FLB_CONFIG_MAP_SIZE, \"receive_buffer_size\", (char *)NULL,\n+      0, FLB_TRUE, offsetof(struct flb_syslog, receive_buffer_size),\n       \"Set the socket receiving buffer size\"\n     },\n     \/* EOF *\/","review":"please rename it to `receive_buffer_size` (and adjust all other name references.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":" static int get_mode(unsigned int attr)\n \n static int64_t filetime_to_epoch(FILETIME ft)\n {\n-    int64_t ldap;\n \n     \/*\n      * The LDAP timestamp represents the number of\n      * 100-nanosecond intervals since Jan 1, 1601 UTC.\n      *\/\n-    ldap = UINT64(ft.dwHighDateTime, ft.dwLowDateTime);\n-    return (ldap \/ LDAP_TO_SECONDS_DIVISOR) - LDAP_TO_EPOCH_DIFF_SECONDS;\n }\n \n static int is_symlink(const char *path)","new":" static int get_mode(unsigned int attr)\n \n static int64_t filetime_to_epoch(FILETIME ft)\n {\n+    ULARGE_INTEGER ldap;\n \n     \/*\n      * The LDAP timestamp represents the number of\n      * 100-nanosecond intervals since Jan 1, 1601 UTC.\n      *\/\n+    ldap.HighPart = ft.dwHighDateTime;\n+    ldap.LowPart = ft.dwLowDateTime;\n+\n+    return ((int64_t) ldap.QuadPart \/ LDAP_TO_SECONDS_DIVISOR) - LDAP_TO_EPOCH_DIFF_SECONDS;\n }\n \n static int is_symlink(const char *path)","review":"Please use a [ULARGE_INTEGER](https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/winnt\/ns-winnt-ularge_integer-r1) to store the QWORD instead of that custom cast.\r\n","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[11,12,5],"loc_wrong_easy":[[1,2,3],[4,6,7],[8,9,10]],"loc_wrong_hard":[[1,11,5],[1,12,5],[1,11,12]]}
{"old":" static void handle_var_stack_access(RAnalEsil *esil, ut64 addr, RAnalVarAccessTy\n \t\tif (addr >= spaddr && addr < ctx->initial_sp) {\n \t\t\tint stack_off = addr - ctx->initial_sp;\n \t\t\t\/\/ int stack_off = ctx->initial_sp - addr; \/\/ R2STACK\n-\t\t\teprintf (\"%x\\n\", stack_off);\n \t\t\t\/\/ eprintf (\" (%llx) %llx = %d\\n\", ctx->initial_sp, addr, stack_off);\n \t\t\tRAnalVar *var = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, stack_off);\n \t\t\tif (!var) {","new":" static void handle_var_stack_access(RAnalEsil *esil, ut64 addr, RAnalVarAccessTy\n \t\tif (addr >= spaddr && addr < ctx->initial_sp) {\n \t\t\tint stack_off = addr - ctx->initial_sp;\n \t\t\t\/\/ int stack_off = ctx->initial_sp - addr; \/\/ R2STACK\n \t\t\t\/\/ eprintf (\" (%llx) %llx = %d\\n\", ctx->initial_sp, addr, stack_off);\n \t\t\tRAnalVar *var = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, stack_off);\n \t\t\tif (!var) {","review":"FYI, this will spam console when running `aaa`.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" R_API void r_core_diff_show_json(RCore *c, RCore *c2) {\n \tconst char *match;\n \tRListIter *iter;\n \tRAnalFunction *f;\n-\tPJ *pj = pj_new ();\n \n \tif (!pj) {\n \t\treturn;","new":" R_API void r_core_diff_show_json(RCore *c, RCore *c2) {\n \tconst char *match;\n \tRListIter *iter;\n \tRAnalFunction *f;\n+\tPJ *pj = core_pj_new ();\n \n \tif (!pj) {\n \t\treturn;","review":"Better use the corepj.new() if you have access to the core instance. This way the user have the ability to configure some options like indent, colors or how to represent 64bit numbers if they want","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static char *pickle_mnemonics(RAnal *a, int id, bool json) {\n \t}\n \tif (id >= 0 && id < R_ARRAY_SIZE (op_name_map)) {\n \t\treturn strdup (op_name_map[id].name);\n-\t} else if (id == -1) {\n \t\tsize_t i;\n \t\tRStrBuf *buf = buf = r_strbuf_new (\"\");\n \t\tfor (i = 0; i < R_ARRAY_SIZE (op_name_map); i++) {","new":" static char *pickle_mnemonics(RAnal *a, int id, bool json) {\n \t}\n \tif (id >= 0 && id < R_ARRAY_SIZE (op_name_map)) {\n \t\treturn strdup (op_name_map[id].name);\n+\t}\n+\tif (id == -1) {\n \t\tsize_t i;\n \t\tRStrBuf *buf = buf = r_strbuf_new (\"\");\n \t\tfor (i = 0; i < R_ARRAY_SIZE (op_name_map); i++) {","review":"dont else after return","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static int archinfo(RAnal *anal, int q) {\n \tcase R_ANAL_ARCHINFO_MIN_OP_SIZE:\n \t\treturn 2;\n \tcase R_ANAL_ARCHINFO_DATA_ALIGN:\n \t\tconst char *cpu = anal->config->cpu;\n \t\tif (strstr (cpu, \"68030\") || strstr (cpu, \"68040\") || strstr (cpu, \"68060\")) {\n \t\t\treturn 1;\n-\t\t} else {\n-\t\t\treturn 2;\n \t\t}\n \t}\n \treturn 2;","new":" static int archinfo(RAnal *anal, int q) {\n \tcase R_ANAL_ARCHINFO_MIN_OP_SIZE:\n \t\treturn 2;\n \tcase R_ANAL_ARCHINFO_DATA_ALIGN:\n+\t\t{\n \t\tconst char *cpu = anal->config->cpu;\n \t\tif (strstr (cpu, \"68030\") || strstr (cpu, \"68040\") || strstr (cpu, \"68060\")) {\n \t\t\treturn 1;\n+\t\t}\n+\t\treturn 2;\n \t\t}\n \t}\n \treturn 2;","review":"Dont else after return","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[8,9],"loc_wrong_easy":[[1,2],[3,4],[5,6]],"loc_wrong_hard":[[8,1],[1,9],[8,2]]}
{"old":" static int cmd_info(void *data, const char *input) {\n \t\t\t\tconst char *match = r_str_trim_head_ro (input + 2);\n \t\t\t\tif (*match) {\n \t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n-\t\t\t\t\t        if (cls->super && strstr (cls->super, match)) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->super);\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->name);\n \t\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", cls->super, cls->name);\n \t\t\t\t\t\t} else if (strstr (cls->name, match)) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->name);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tgoto done;\n \t\t\t\t}\n-\t\t\t\tif (fullGraph) {\n \t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n \t\t\t\t\t\tif (cls->super) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->super);","new":" static int cmd_info(void *data, const char *input) {\n \t\t\t\tconst char *match = r_str_trim_head_ro (input + 2);\n \t\t\t\tif (*match) {\n \t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n+\t\t\t\t\t    if (cls->super && strstr (cls->super, match)) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->super);\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->name);\n \t\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", cls->super, cls->name);\n \t\t\t\t\t\t} else if (strstr (cls->name, match)) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->name);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+                else if (fullGraph) {\n \t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n \t\t\t\t\t\tif (cls->super) {\n \t\t\t\t\t\t\tr_cons_printf (\"agn %s\\n\", cls->super);","review":"the code below should be after `} else ` otherwise the `grepping` will just print twice and dont work as expected","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[13,5,15],"loc_wrong_easy":[[1,2,3],[4,6,7],[8,9,10]],"loc_wrong_hard":[[1,13,5],[1,5,15],[1,13,15]]}
{"old":" extern void bzero(void *, int);\n #  ifndef WIN32_LEAN_AND_MEAN\n #    define WIN32_LEAN_AND_MEAN\n #  endif\n-#  ifdef MS_WINDOWS_GAMES\n-#    include <winsock2.h>\n-#  else\n-#    include <winsock.h>\n-#  endif\n #else\n #  define SOCKET int\n #endif","new":" extern void bzero(void *, int);\n #  ifndef WIN32_LEAN_AND_MEAN\n #    define WIN32_LEAN_AND_MEAN\n #  endif\n+#  include <winsock2.h>\n #else\n #  define SOCKET int\n #endif","review":"Can we not just use `winsock2.h` unconditionally?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5],[1,2,6,7,10],[1,2,8,9,11]],"loc_wrong_hard":[[1,5,6,7,8],[1,5,6,7,9],[1,5,6,8,9]]}
{"old":" _PyGen_FetchStopIterationValue(PyObject **pvalue)\n     PyObject *value = NULL;\n     if (PyErr_ExceptionMatches(PyExc_StopIteration)) {\n         PyObject *exc = PyErr_GetRaisedException();\n-        if (exc) {\n-            \/* exception will usually be normalised already *\/\n-            value = Py_NewRef(((PyStopIterationObject *)exc)->value);\n-            Py_DECREF(exc);\n-        }\n     } else if (PyErr_Occurred()) {\n         return -1;\n     }","new":" _PyGen_FetchStopIterationValue(PyObject **pvalue)\n     PyObject *value = NULL;\n     if (PyErr_ExceptionMatches(PyExc_StopIteration)) {\n         PyObject *exc = PyErr_GetRaisedException();\n+        value = Py_NewRef(((PyStopIterationObject *)exc)->value);\n+        Py_DECREF(exc);\n     } else if (PyErr_Occurred()) {\n         return -1;\n     }","review":"If `PyErr_ExceptionMatches` return true, doesn't that mean that `PyErr_GetRaisedException()` must return non-NULL?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5],[1,2,6,7,10],[1,2,8,9,11]],"loc_wrong_hard":[[1,5,6,7,8],[1,5,6,7,9],[1,5,6,8,9]]}
{"old":" set_attribute_error_context(PyObject* v, PyObject* name)\n     }\n     \/\/ Intercept AttributeError exceptions and augment them to offer suggestions later.\n     PyObject *exc = PyErr_GetRaisedException();\n-    \/\/ Check if the exception is indeed an AttributeError\n     if (!PyErr_GivenExceptionMatches(exc, PyExc_AttributeError)) {\n         goto restore;\n     }","new":" set_attribute_error_context(PyObject* v, PyObject* name)\n     }\n     \/\/ Intercept AttributeError exceptions and augment them to offer suggestions later.\n     PyObject *exc = PyErr_GetRaisedException();\n     if (!PyErr_GivenExceptionMatches(exc, PyExc_AttributeError)) {\n         goto restore;\n     }","review":"This comment seems redundant. What else could `PyErr_GivenExceptionMatches(exc, PyExc_AttributeError)` do?","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" random_seed_time_pid(RandomObject *self)\n     key[0] = (uint32_t)(now & 0xffffffffU);\n     key[1] = (uint32_t)(now >> 32);\n \n-#ifdef HAVE_GETPID\n-    key[2] = (uint32_t)getpid();\n-#elif defined(MS_WINDOWS_NON_DESKTOP)\n     key[2] = (uint32_t)GetCurrentProcessId();\n #else\n     key[2] = 0;\n #endif","new":" random_seed_time_pid(RandomObject *self)\n     key[0] = (uint32_t)(now & 0xffffffffU);\n     key[1] = (uint32_t)(now >> 32);\n \n+#ifdef MS_WINDOWS_NON_DESKTOP\n     key[2] = (uint32_t)GetCurrentProcessId();\n+#elif defined(HAVE_GETPID)\n+    key[2] = (uint32_t)getpid();\n #else\n     key[2] = 0;\n #endif","review":"This case will need to be ordered above `HAVE_GETPID` with the changes mentioned in other comments. There's no problem with that.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7],"loc_wrong_easy":[[1,2,3],[1,4,5],[8,1,6]],"loc_wrong_hard":[[1,5,6],[1,5,7],[1,6,7]]}
{"old":" dummy_func(\n             else {\n                 \/* `iterable` is not a generator. *\/\n                 iter = PyObject_GetIter(iterable);\n-                Py_DECREF(iterable);\n                 if (iter == NULL) {\n                     goto error;\n                 }\n             }\n             PREDICT(LOAD_CONST);\n         }","new":" dummy_func(\n             else {\n                 \/* `iterable` is not a generator. *\/\n                 iter = PyObject_GetIter(iterable);\n                 if (iter == NULL) {\n                     goto error;\n                 }\n+                Py_DECREF(iterable);\n             }\n             PREDICT(LOAD_CONST);\n         }","review":"This seems unsafe -- when we jump to `error`, `iterable` is still on the stack, but the stack no longer owns it.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" os__isfile_impl(PyObject *module, PyObject *path)\n                             OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n     }\n     if (hfile != INVALID_HANDLE_VALUE) {\n-        GetFileInformationByHandleEx(hfile, FileBasicInfo, &info, sizeof(info));\n-        result = !(info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);\n-        if (result) {\n-            fileType = GetFileType(hfile);\n-            if (fileType != FILE_TYPE_DISK) {\n-                result = 0;\n-            }\n         }\n         if (close_file) {\n             CloseHandle(hfile);","new":" os__isfile_impl(PyObject *module, PyObject *path)\n                             OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n     }\n     if (hfile != INVALID_HANDLE_VALUE) {\n+        if (GetFileInformationByHandleEx(hfile, FileBasicInfo, &info, sizeof(info))) {\n+            result = !(info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);\n+        } else {\n+            result = 0;\n         }\n         if (close_file) {\n             CloseHandle(hfile);","review":"Unlike `isdir()`, for `isfile()` you need to check whether `GetFileInformationByHandleEx()` succeeds. It's a filesystem file\/directory if the call succeeds. For example, \"\\\\\\\\.\\\\PIPE\\\\\" is the root directory of the named-pipe filesystem. OTOH, \"\\\\\\\\.\\\\C:\" is a volume a device, which doesn't support filesystem information classes such as `FileBasicInfo`.\r\n","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7,8,9,10,11],"loc_wrong_easy":[[1,2,3,4,5,6,7],[1,2,3,4,8,9,10],[1,2,3,4,11,12,13]],"loc_wrong_hard":[[1,5,6,7,8,9,10],[1,5,6,7,8,9,11],[1,5,6,7,8,10,11]]}
{"old":" static vine_msg_code_t vine_manager_recv_no_retry(struct vine_manager *q, struct\n \t\tresult = handle_cache_update(q, w, line);\n \t} else if (string_prefix_is(line, \"cache-invalid\")) {\n \t\tresult = handle_cache_invalid(q, w, line);\n-\t} \n-\/\/\telse if (string_prefix_is(line, \"worker-init\")) {\n-\/\/\t\tresult = handle_worker_init(q, w, line);\n-\/\/\t} \n-\telse if (string_prefix_is(line, \"transfer-address\")) {\n \t\tresult = handle_transfer_address(q, w, line);\n \t} else if( sscanf(line,\"GET %s HTTP\/%*d.%*d\",path)==1) {\n \t        result = handle_http_request(q,w,path,stoptime);","new":" static vine_msg_code_t vine_manager_recv_no_retry(struct vine_manager *q, struct\n \t\tresult = handle_cache_update(q, w, line);\n \t} else if (string_prefix_is(line, \"cache-invalid\")) {\n \t\tresult = handle_cache_invalid(q, w, line);\n+\t} else if (string_prefix_is(line, \"transfer-address\")) {\n \t\tresult = handle_transfer_address(q, w, line);\n \t} else if( sscanf(line,\"GET %s HTTP\/%*d.%*d\",path)==1) {\n \t        result = handle_http_request(q,w,path,stoptime);","review":"This seems incomplete.  Did you mean to finish this, or is it meant to be part of a future PR?\r\n","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5],[1,2,6,7,10],[1,2,8,9,11]],"loc_wrong_hard":[[1,5,6,7,8],[1,5,6,7,9],[1,5,6,8,9]]}
{"old":" static void workspace_delete()\n \tis inside the workspace.  Abort if we really cannot clean up.\n \t*\/\n \n-\/\/\tunlink_recursive(workspace);\n \n \tfree(workspace);\n }","new":" static void workspace_delete()\n \tis inside the workspace.  Abort if we really cannot clean up.\n \t*\/\n \n \n \tfree(workspace);\n }","review":"Don't check in dead code, just delete it.\r\n","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" void * itable_pop( struct itable *t )\n \tvoid *value;\n \n \titable_firstkey(t);\n-\tif(itable_nextkey(t, &key, (void*)&value)) {\n \t\treturn itable_remove(t,key);\n \t} else {\n \t\treturn 0;","new":" void * itable_pop( struct itable *t )\n \tvoid *value;\n \n \titable_firstkey(t);\n+\tif(itable_nextkey(t, &key, (void**)&value)) {\n \t\treturn itable_remove(t,key);\n \t} else {\n \t\treturn 0;","review":"(void **) ? I think compilers may complain otherwise.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int main(int argc, char *const *argv)\n             GUARD_EXIT(renegotiate(conn, sockfd, reneg_ctx.wait), \"Renegotiation failed\");\n         }\n \n-        wait_for_shutdown(conn, sockfd);\n \n         GUARD_EXIT(s2n_connection_free(conn), \"Error freeing connection\");\n ","new":" int main(int argc, char *const *argv)\n             GUARD_EXIT(renegotiate(conn, sockfd, reneg_ctx.wait), \"Renegotiation failed\");\n         }\n \n+        GUARD_EXIT(wait_for_shutdown(conn, sockfd), \"Error closing connection\");\n \n         GUARD_EXIT(s2n_connection_free(conn), \"Error freeing connection\");\n ","review":"Since `wait_for_event` can return an error, should this `wait_for_shutdown` have a GUARD_EXIT? Or should it still continue here if that happens?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"\n \n S2N_RESULT s2n_handshake_transcript_update(struct s2n_connection *conn)\n {\n     struct s2n_stuffer message = conn->handshake.io;\n     RESULT_GUARD_POSIX(s2n_stuffer_reread(&message));\n ","new":"\n \n S2N_RESULT s2n_handshake_transcript_update(struct s2n_connection *conn)\n {\n+    RESULT_ENSURE_REF(conn);\n+\n     struct s2n_stuffer message = conn->handshake.io;\n     RESULT_GUARD_POSIX(s2n_stuffer_reread(&message));\n ","review":"nit: probably should RESULT_ENSURE_REF(conn)","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" const char *s2n_connection_get_handshake_type_name(struct s2n_connection *conn)\n \n S2N_RESULT s2n_handshake_message_send(struct s2n_connection *conn, uint8_t content_type, s2n_blocked_status *blocked)\n {\n     struct s2n_stuffer *in = &conn->handshake.io;\n \n     uint32_t size = s2n_stuffer_data_available(in);","new":" const char *s2n_connection_get_handshake_type_name(struct s2n_connection *conn)\n \n S2N_RESULT s2n_handshake_message_send(struct s2n_connection *conn, uint8_t content_type, s2n_blocked_status *blocked)\n {\n+    RESULT_ENSURE_REF(conn);\n     struct s2n_stuffer *in = &conn->handshake.io;\n \n     uint32_t size = s2n_stuffer_data_available(in);","review":"Nit: probably should ENSURE_REF(conn) here","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":" static int s2n_signature_scheme_valid_to_accept(struct s2n_connection *conn, con\n     if (conn->actual_protocol_version >= S2N_TLS13) {\n         POSIX_ENSURE_NE(scheme->hash_alg, S2N_HASH_SHA1);\n         POSIX_ENSURE_NE(scheme->sig_alg, S2N_SIGNATURE_RSA);\n-    }\n-\n-    if (conn->actual_protocol_version < S2N_TLS13) {\n         POSIX_ENSURE_NE(scheme->sig_alg, S2N_SIGNATURE_RSA_PSS_PSS);\n     }\n ","new":" static int s2n_signature_scheme_valid_to_accept(struct s2n_connection *conn, con\n     if (conn->actual_protocol_version >= S2N_TLS13) {\n         POSIX_ENSURE_NE(scheme->hash_alg, S2N_HASH_SHA1);\n         POSIX_ENSURE_NE(scheme->sig_alg, S2N_SIGNATURE_RSA);\n+    } else {\n         POSIX_ENSURE_NE(scheme->sig_alg, S2N_SIGNATURE_RSA_PSS_PSS);\n     }\n ","review":"Can't this now just be an else?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5,6,7],"loc_wrong_easy":[[1,2,3],[1,4,5],[8,1,6]],"loc_wrong_hard":[[1,5,6],[1,5,7],[1,6,7]]}
{"old":" struct s2n_cipher_suite *cipher_suites_cloudfront_tls_1_2_2017[] = {\n     &s2n_ecdhe_rsa_with_chacha20_poly1305_sha256,\n     &s2n_ecdhe_ecdsa_with_aes_256_cbc_sha384,\n     &s2n_ecdhe_rsa_with_aes_256_cbc_sha384,\n-    &s2n_ecdhe_rsa_with_aes_256_cbc_sha,\n     &s2n_ecdhe_ecdsa_with_aes_256_cbc_sha,\n     &s2n_rsa_with_aes_128_gcm_sha256,\n     &s2n_rsa_with_aes_256_gcm_sha384,\n     &s2n_rsa_with_aes_128_cbc_sha256","new":" struct s2n_cipher_suite *cipher_suites_cloudfront_tls_1_2_2017[] = {\n     &s2n_ecdhe_rsa_with_chacha20_poly1305_sha256,\n     &s2n_ecdhe_ecdsa_with_aes_256_cbc_sha384,\n     &s2n_ecdhe_rsa_with_aes_256_cbc_sha384,\n     &s2n_ecdhe_ecdsa_with_aes_256_cbc_sha,\n+    &s2n_ecdhe_rsa_with_aes_256_cbc_sha,\n     &s2n_rsa_with_aes_128_gcm_sha256,\n     &s2n_rsa_with_aes_256_gcm_sha384,\n     &s2n_rsa_with_aes_128_cbc_sha256","review":"really minor, but everything before orders ECDSA before RSA variant, this one inverses it. In our case it does not matter as we only support 1 cert type, but eventually when we provide dual support, we'd prefer ECDSA to be picked over RSA.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" symtable_extend_namedexpr_scope(struct symtable *st, expr_ty e)\n         if (ste->ste_comprehension) {\n             long target_in_scope = _PyST_GetSymbol(ste, target_name);\n             if ((target_in_scope & DEF_COMP_ITER) &&\n-                (target_in_scope & (DEF_LOCAL | DEF_GLOBAL))) {\n                 PyErr_Format(PyExc_SyntaxError, NAMED_EXPR_COMP_CONFLICT, target_name);\n                 PyErr_RangedSyntaxLocationObject(st->st_filename,\n                                                   e->lineno,","new":" symtable_extend_namedexpr_scope(struct symtable *st, expr_ty e)\n         if (ste->ste_comprehension) {\n             long target_in_scope = _PyST_GetSymbol(ste, target_name);\n             if ((target_in_scope & DEF_COMP_ITER) &&\n+                (target_in_scope & DEF_LOCAL)) {\n                 PyErr_Format(PyExc_SyntaxError, NAMED_EXPR_COMP_CONFLICT, target_name);\n                 PyErr_RangedSyntaxLocationObject(st->st_filename,\n                                                   e->lineno,","review":"Hmm, should this also check `DEF_NONLOCAL`?\r\n\r\nActually, looking closer, I think `DEF_GLOBAL` might be impossible, because we already check for it when setting `DEF_COMP_ITER`. Or at least, tests pass without checking `DEF_GLOBAL` here.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" S2N_RESULT s2n_early_data_record_bytes(struct s2n_connection *conn, ssize_t data\n     if (data_len < 0 || !s2n_is_early_data_io(conn)) {\n         return S2N_RESULT_OK;\n     }\n-    \/* Check to ensure data_len is non-negative *\/\n-    RESULT_ENSURE_GTE(data_len, 0);\n \n     \/* Ensure the bytes read are within the bounds of what we can actually record. *\/\n     if ((size_t) data_len > (UINT64_MAX - conn->early_data_bytes)) {","new":" S2N_RESULT s2n_early_data_record_bytes(struct s2n_connection *conn, ssize_t data\n     if (data_len < 0 || !s2n_is_early_data_io(conn)) {\n         return S2N_RESULT_OK;\n     }\n \n     \/* Ensure the bytes read are within the bounds of what we can actually record. *\/\n     if ((size_t) data_len > (UINT64_MAX - conn->early_data_bytes)) {","review":"`data_len` is already being checked to see if it's negative above this, so this additional check seems unnecessary. ","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5,6],"loc_wrong_easy":[[1,2],[3,4],[8,7]],"loc_wrong_hard":[[1,5],[1,6],[2,5]]}
{"old":" static int s2n_rsa_decrypt(const struct s2n_pkey *priv, struct s2n_blob *in, str\n     \/* Safety: RSA_private_decrypt does not mutate the key *\/\n     int r = RSA_private_decrypt(in->size, (unsigned char *) in->data, intermediate,\n             s2n_unsafe_rsa_get_non_const(priv_key), RSA_NO_PADDING);\n-    POSIX_ENSURE((int64_t) r == expected_size, S2N_ERR_SIZE_MISMATCH);\n \n     s2n_constant_time_pkcs1_unpad_or_dont(out->data, intermediate, r, out->size);\n ","new":" static int s2n_rsa_decrypt(const struct s2n_pkey *priv, struct s2n_blob *in, str\n     \/* Safety: RSA_private_decrypt does not mutate the key *\/\n     int r = RSA_private_decrypt(in->size, (unsigned char *) in->data, intermediate,\n             s2n_unsafe_rsa_get_non_const(priv_key), RSA_NO_PADDING);\n+    POSIX_ENSURE((int64_t) r == (int64_t) expected_size, S2N_ERR_SIZE_MISMATCH);\n \n     s2n_constant_time_pkcs1_unpad_or_dont(out->data, intermediate, r, out->size);\n ","review":"Same problem here I think. expected_size is unsigned.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static int s2n_server_cert_status_request_send(struct s2n_connection *conn, stru\n \n static bool s2n_server_cert_status_request_should_send(struct s2n_connection *conn)\n {\n-    return conn->config->status_request_type != S2N_STATUS_REQUEST_NONE;\n }","new":" static int s2n_server_cert_status_request_send(struct s2n_connection *conn, stru\n \n static bool s2n_server_cert_status_request_should_send(struct s2n_connection *conn)\n {\n+    return conn->config->status_request_type == S2N_STATUS_REQUEST_OCSP;\n }","review":"Why not == S2N_STATUS_REQUEST_OCSP?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" int s2n_server_status_request_recv(struct s2n_connection *conn, struct s2n_stuff\n \n \/* Old-style extension functions -- remove after extensions refactor is complete *\/\n \n-\/* used in fuzz test *\/\n int s2n_recv_server_status_request(struct s2n_connection *conn, struct s2n_stuffer *extension)\n {\n     return s2n_extension_recv(&s2n_server_status_request_extension, conn, extension);","new":" int s2n_server_status_request_recv(struct s2n_connection *conn, struct s2n_stuff\n \n \/* Old-style extension functions -- remove after extensions refactor is complete *\/\n \n int s2n_recv_server_status_request(struct s2n_connection *conn, struct s2n_stuffer *extension)\n {\n     return s2n_extension_recv(&s2n_server_status_request_extension, conn, extension);","review":"Are these comments necessary? Searching for occurrences of the method should return the fuzz tests just like the unit tests. What if we remove the fuzz test reference, but don't clean up this comment?","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" R_API void r_core_diff_show_json(RCore *c, RCore *c2) {\n \n \tfcns = r_anal_get_fcns (c->anal);\n \tif (r_list_empty (fcns)) {\n-\t\tR_LOG_INFO (\"No functions found, try running with -A or load a project\");\n \t\treturn;\n \t}\n ","new":" R_API void r_core_diff_show_json(RCore *c, RCore *c2) {\n \n \tfcns = r_anal_get_fcns (c->anal);\n \tif (r_list_empty (fcns)) {\n+\t\tR_LOG_ERROR (\"No functions found, try running with -A or load a project\");\n \t\treturn;\n \t}\n ","review":"Yes, error seems more correct indeed.\r\n\r\n","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" static st32 parse_type(Context *ctx, const ut64 offset, RStrBuf *strbuf, ut64 *s\n \t\t*visited = su;\n \t}\n \tif (visited && set_u_contains (*visited, offset)) {\n-\t\tR_LOG_WARN (\"Warning: anal.dwarf.parse_type: infinite recursion detected.\");\n \t\treturn -1;\n \t}\n \tset_u_add (*visited, offset);","new":" static st32 parse_type(Context *ctx, const ut64 offset, RStrBuf *strbuf, ut64 *s\n \t\t*visited = su;\n \t}\n \tif (visited && set_u_contains (*visited, offset)) {\n+\t\tR_LOG_WARN (\"anal.dwarf.parse_type: infinite recursion detected.\");\n \t\treturn -1;\n \t}\n \tset_u_add (*visited, offset);","review":"Remove Warning: too","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"\n \/* Include symbols from _socket module *\/\n #include \"socketmodule.h\"\n \n-#ifdef MS_WINDOWS_GAMES\n #  include <wincrypt.h>\n #endif\n ","new":"\n \/* Include symbols from _socket module *\/\n #include \"socketmodule.h\"\n \n+#ifdef MS_WINDOWS\n #  include <wincrypt.h>\n #endif\n ","review":"Similarly, any harm in just making this `MS_WINDOWS`?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" odict_repr(PyODictObject *self)\n     result = PyUnicode_FromFormat(\"%s(%R)\",\n                                   _PyType_Name(Py_TYPE(self)),\n                                   dcopy);\n \n Done:\n     Py_ReprLeave((PyObject *)self);\n-    Py_XDECREF(dcopy);\n     return result;\n }\n ","new":" odict_repr(PyODictObject *self)\n     result = PyUnicode_FromFormat(\"%s(%R)\",\n                                   _PyType_Name(Py_TYPE(self)),\n                                   dcopy);\n+    Py_DECREF(dcopy);\n \n Done:\n     Py_ReprLeave((PyObject *)self);\n     return result;\n }\n ","review":"You can move it above the `Done` label and change `Py_XDECREF` to `Py_DECREF`.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[8],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":" }\n \/*\n- * flb_sds_snprintf_realloc is a wrapper of snprintf.\n  * The difference is that this function can increase the buffer of flb_sds_t.\n  *\/\n-int flb_sds_snprintf_realloc(flb_sds_t *str, size_t size, const char *fmt, ...)\n {\n     va_list va;\n     flb_sds_t tmp;","new":" }\n \/*\n+ * flb_sds_snprintf is a wrapper of snprintf.\n  * The difference is that this function can increase the buffer of flb_sds_t.\n  *\/\n+int flb_sds_snprintf(flb_sds_t *str, size_t size, const char *fmt, ...)\n {\n     va_list va;\n     flb_sds_t tmp;","review":"I think this function is not necessary and we can simply rely on flb_sds_printf() functionality. flb_sds_t by default always reallocate if necessary, and calculating the final length can be done with flb_sds_len()","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3,6],"loc_wrong_easy":[[1,2],[4,5],[8,7]],"loc_wrong_hard":[[1,3],[1,6],[2,3]]}
{"old":"     ret = prepare_destroy_conn(u_conn);\n-    if (u->thread_safe == FLB_TRUE && locked) {\n         pthread_mutex_unlock(&u->mutex_lists);\n     }","new":"     ret = prepare_destroy_conn(u_conn);\n+    if (locked) {\n         pthread_mutex_unlock(&u->mutex_lists);\n     }","review":"`locked` is only assigned if `u->thread_safe` is `FLB_TRUE` so in the unlock section we could just do `if (locked) {`","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[2],"loc_wrong_easy":[[1],[3],[4]],"loc_wrong_hard":[[1],[3],[4]]}
{"old":"     \/* Initialize context *\/\n     ctx = flb_calloc(1, sizeof(struct winevtlog_config));\n-    if (!ctx) {\n         flb_errno();\n         return -1;\n     }","new":"     \/* Initialize context *\/\n     ctx = flb_calloc(1, sizeof(struct winevtlog_config));\n+    if (ctx == NULL) {\n         flb_errno();\n         return -1;\n     }","review":"Could you change this to explicitly compare against NULL? (same goes for other occurrences but I won't spam the diffs with this)","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":" \tq->long_timeout = 3600;\n \tq->stats->time_when_started = timestamp_get();\n-\tq->stats->time_when_compatibility_checked = timestamp_get();\n \tq->task_reports = list_create();\n \tq->time_last_wait = 0;","new":" \tq->long_timeout = 3600;\n \tq->stats->time_when_started = timestamp_get();\n+\tq->last_time_tasks_fit_check = timestamp_get();\n \tq->task_reports = list_create();\n \tq->time_last_wait = 0;","review":"@Cpreciad I think this one is better as a field of q (e.g. `q->last_time_tasks_fit_check`), as this is not really a stat.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":" \tbool found = false;\n-\tstruct wlr_drm_format_set *dmabuf_formats[WLR_VK_IMAGE_USAGE_COUNT] = {\n-\t\t[WLR_VK_IMAGE_USAGE_RENDER] = &dev->dmabuf_render_formats,\n-\t\t[WLR_VK_IMAGE_USAGE_SAMPLED] = &dev->dmabuf_texture_formats,\n-\t};\n-\n \tfor (unsigned i = 0u; i < modp.drmFormatModifierCount; ++i) {\n \t\tVkDrmFormatModifierPropertiesEXT m =\n \t\t\tmodp.pDrmFormatModifierProperties[i];","new":" \tbool found = false;\n \tfor (unsigned i = 0u; i < modp.drmFormatModifierCount; ++i) {\n \t\tVkDrmFormatModifierPropertiesEXT m =\n \t\t\tmodp.pDrmFormatModifierProperties[i];","review":"You never add to this format_set anymore more if I didn't miss anything. This seems like a problem.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[2,3,4,5,6],"loc_wrong_easy":[[1,2,3,4,7],[1,2,3,5,8],[1,2,3,6,9]],"loc_wrong_hard":[[1,2,3,4,5],[1,2,3,4,6],[1,2,3,5,6]]}
{"old":"   }\n   if(!infer_locals(opt, left, r_type))\n-  {\n-    \/*\n-    TODO: maybe add an ast_error here too, but I don't\n-    know what error would happen here ~ mateus-md\n-    *\/\n     return false;\n-  }\n   \/\/ Inferring locals may have changed the left type.\n   l_type = ast_type(left);","new":"   }\n   if(!infer_locals(opt, left, r_type))\n     return false;\n   \/\/ Inferring locals may have changed the left type.\n   l_type = ast_type(left);","review":"This should be removed before this would be merged.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[3,4,5,6,7,9],"loc_wrong_easy":[[1,2,3,4,5,6],[1,2,3,4,7,8],[1,2,3,4,9,10]],"loc_wrong_hard":[[1,3,4,5,6,7],[1,3,4,5,6,9],[1,3,4,5,7,9]]}
{"old":"                                                      const uint8_t **src, const uint8_t *src_end, unsigned prefix_bits,\n                                                      const char **err_desc)\n {\n-    assert(base_index >= 0);\n     int64_t off;\n     if (decode_int(&off, src, src_end, prefix_bits) != 0 || off >= base_index) {","new":"                                                      const uint8_t **src, const uint8_t *src_end, unsigned prefix_bits,\n                                                      const char **err_desc)\n {\n     int64_t off;\n     if (decode_int(&off, src, src_end, prefix_bits) != 0 || off >= base_index) {","review":"Maybe we do not need this, assuming that we add the assertion to `parse_decode_context` as you did in this PR?","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[4],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"             EXPECT_SUCCESS(s2n_client_hello_send(client_conn));\n             EXPECT_SUCCESS(s2n_stuffer_copy(&client_conn->handshake.io, &server_conn->handshake.io,\n                     s2n_stuffer_data_available(&client_conn->handshake.io)));\n-            if (s2n_is_tls_12_self_downgrade_required(client_conn)) {\n-                EXPECT_FAILURE_WITH_ERRNO(s2n_client_hello_recv(server_conn), S2N_ERR_PROTOCOL_VERSION_UNSUPPORTED);\n-            } else {\n-                EXPECT_SUCCESS(s2n_client_hello_recv(server_conn));\n-            }\n             s2n_connection_free(client_conn);\n             s2n_connection_free(server_conn);","new":"             EXPECT_SUCCESS(s2n_client_hello_send(client_conn));\n             EXPECT_SUCCESS(s2n_stuffer_copy(&client_conn->handshake.io, &server_conn->handshake.io,\n                     s2n_stuffer_data_available(&client_conn->handshake.io)));\n+\n+            EXPECT_SUCCESS(s2n_client_hello_recv(server_conn));\n+\n             s2n_connection_free(client_conn);\n             s2n_connection_free(server_conn);","review":"This test isn't interested in fallback behavior. TLS1.2 + QUIC always fails, but we're not testing that here. Probably worth restricting it to TLS1.3 only. Same for the next one.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4,5,6,7,8],"loc_wrong_easy":[[1,2,3,4,5],[1,2,3,6,7],[1,2,3,8,9]],"loc_wrong_hard":[[1,4,5,6,7],[1,4,5,6,8],[1,4,5,7,8]]}
{"old":"      *# A client that attempts to send 0-RTT data MUST fail a connection if\n      *# it receives a ServerHello with TLS 1.2 or older.\n      *\/\n-    {\n         EXPECT_SUCCESS(s2n_reset_tls13());\n         struct s2n_config *config = s2n_config_new();\n         EXPECT_SUCCESS(s2n_config_add_cert_chain_and_key_to_store(config, chain_and_key));\n         \/* Succeeds when negotiating TLS1.3 *\/\n-        if (s2n_is_tls13_fully_supported()) {\n             struct s2n_connection *client_conn = s2n_connection_new(S2N_CLIENT);\n             EXPECT_SUCCESS(s2n_connection_set_config(client_conn, config));\n             EXPECT_SUCCESS(s2n_connection_set_cipher_preferences(client_conn, \"test_all\"));","new":"      *# A client that attempts to send 0-RTT data MUST fail a connection if\n      *# it receives a ServerHello with TLS 1.2 or older.\n      *\/\n+    if (s2n_is_tls13_fully_supported()) {\n         EXPECT_SUCCESS(s2n_reset_tls13());\n         struct s2n_config *config = s2n_config_new();\n         EXPECT_SUCCESS(s2n_config_add_cert_chain_and_key_to_store(config, chain_and_key));\n         \/* Succeeds when negotiating TLS1.3 *\/\n+        {\n             struct s2n_connection *client_conn = s2n_connection_new(S2N_CLIENT);\n             EXPECT_SUCCESS(s2n_connection_set_config(client_conn, config));\n             EXPECT_SUCCESS(s2n_connection_set_cipher_preferences(client_conn, \"test_all\"));","review":"I would just move this if to line 4. Both the success\/failures versions of this test require the client to use TLS1.3 because the client must request early data.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[9,4],"loc_wrong_easy":[[1,2],[3,5],[6,7]],"loc_wrong_hard":[[1,4],[1,9],[2,4]]}
{"old":" \t\t\treturn -ENOMEM;\n \t\tst = iio_priv(indio_dev);\n-\t\tspi_set_drvdata(spi, indio_dev);\n \t\tst->spi = spi;\n \t\tst->regmap = regmap;","new":" \t\t\treturn -ENOMEM;\n \t\tst = iio_priv(indio_dev);\n \t\tst->spi = spi;\n \t\tst->regmap = regmap;","review":"since we are here, I do not think this is needed since `spi_set_drvdata()` seems not to be called anywhere...","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"     if (total_data_recv > 0) {\n         fprintf(stdout, \"Early Data received: \");\n-        for (size_t i = 0; i < (ssize_t)total_data_recv; i++) {\n             fprintf(stdout, \"%c\", early_data_received[i]);\n         }\n         fprintf(stdout, \"\\n\");","new":"     if (total_data_recv > 0) {\n         fprintf(stdout, \"Early Data received: \");\n+        for (ssize_t i = 0; i < total_data_recv; i++) {\n             fprintf(stdout, \"%c\", early_data_received[i]);\n         }\n         fprintf(stdout, \"\\n\");","review":"`i` can be a `ssize_t` here as well.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"     return S2N_SUCCESS;\n }\n-int print_connection_data(struct s2n_connection *conn,  bool session_resumed)\n {\n     int client_hello_version;\n     int client_protocol_version;","new":"     return S2N_SUCCESS;\n }\n+int print_connection_data(struct s2n_connection *conn)\n {\n     int client_hello_version;\n     int client_protocol_version;","review":"I see the duplicate call to `s2n_connection_is_session_resumed` passing in `session_resumed` avoids. But from an API design I slightly prefer just passing in the `s2n_connection` and letting print pull out whatever it needs to print.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"             EXPECT_SUCCESS(s2n_connection_free(conn));\n         }\n-        \/* No non-post handshake messages can be received, except HelloRetry during TLS1.2.\n          * This means that no handshake message that appears in the handshake state machine\n          * should be allowed, except TLS_HELLO_REQUEST.\n          *\/","new":"             EXPECT_SUCCESS(s2n_connection_free(conn));\n         }\n+        \/* No non-post handshake messages can be received, except HelloRequest during TLS1.2.\n          * This means that no handshake message that appears in the handshake state machine\n          * should be allowed, except TLS_HELLO_REQUEST.\n          *\/","review":"Wouldn't this be Hello Request?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"                 int max = security_policy->signature_preferences->signature_schemes[i]->maximum_protocol_version;\n                 s2n_signature_algorithm sig_alg = security_policy->signature_preferences->signature_schemes[i]->sig_alg;\n-                if (min >= S2N_TLS13 || max <= S2N_TLS13) {\n                     has_tls_13_sig_alg = 1;\n                 }","new":"                 int max = security_policy->signature_preferences->signature_schemes[i]->maximum_protocol_version;\n                 s2n_signature_algorithm sig_alg = security_policy->signature_preferences->signature_schemes[i]->sig_alg;\n+                if (min == S2N_TLS13 || max >= S2N_TLS13) {\n                     has_tls_13_sig_alg = 1;\n                 }","review":"Not sure how checking for `max <= S2N_TLS13` helps here, are we interested only in the minimum version?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"     return S2N_SUCCESS;\n }\n-int client_hello_noop_cb(struct s2n_connection *conn, void *ctx)\n {\n     return S2N_SUCCESS;\n }","new":"     return S2N_SUCCESS;\n }\n+int static s2n_client_hello_no_op_cb(struct s2n_connection *conn, void *ctx)\n {\n     return S2N_SUCCESS;\n }","review":"should probably make this static \/ add the s2n_ prefix","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":" \t\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n \tOnConflictAction onconflict_action = ts_chunk_dispatch_get_on_conflict_action(dispatch);\n \tResultRelInfo *resrelinfo, *relinfo;\n-\tbool has_compressed_chunk = (chunk->fd.compressed_chunk_id != 0);\n \t\/* permissions NOT checked here; were checked at hypertable level *\/\n \tif (check_enable_rls(chunk->table_id, InvalidOid, false) == RLS_ENABLED)","new":" \t\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n \tOnConflictAction onconflict_action = ts_chunk_dispatch_get_on_conflict_action(dispatch);\n \tResultRelInfo *resrelinfo, *relinfo;\n+\tbool is_compressed = (chunk->fd.compressed_chunk_id != 0);\n \t\/* permissions NOT checked here; were checked at hypertable level *\/\n \tif (check_enable_rls(chunk->table_id, InvalidOid, false) == RLS_ENABLED)","review":"Should `is_compressed` now be given by the chunk's compression status flag? Otherwise it looks like we have different ways of determining compression status.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"         case 'x':\n             req.connect_to = h2o_mem_alloc(sizeof(*req.connect_to));\n             if (h2o_url_init(req.connect_to, NULL, h2o_iovec_init(optarg, strlen(optarg)), h2o_iovec_init(NULL, 0)) != 0 ||\n-                req.connect_to->_port == 0 || req.connect_to->_port == 65535) {\n-                fprintf(stderr, \"invalid server address specified for -X\\n\");\n                 exit(EXIT_FAILURE);\n             }\n             break;","new":"         case 'x':\n             req.connect_to = h2o_mem_alloc(sizeof(*req.connect_to));\n             if (h2o_url_init(req.connect_to, NULL, h2o_iovec_init(optarg, strlen(optarg)), h2o_iovec_init(NULL, 0)) != 0 ||\n+                    req.connect_to->_port == 0 || req.connect_to->_port == 65535) {\n+                fprintf(stderr, \"invalid server address specified for -x\\n\");\n                 exit(EXIT_FAILURE);\n             }\n             break;","review":"sorry for a side-tracked request, but can you add a patch to fix this message as well? I think this must be -x instead of -X.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4,5],"loc_wrong_easy":[[1,2],[3,6],[8,7]],"loc_wrong_hard":[[1,4],[1,5],[2,4]]}
{"old":" }\n void TSDescriptor::UpdateHeartbeat(const TSHeartbeatRequestPB* req) {\n-  std::lock_guard<decltype(lock_)> l(lock_);\n-  last_heartbeat_ = MonoTime::Now();\n-\n   DCHECK_GE(req->num_live_tablets(), 0);\n   DCHECK_GE(req->leader_count(), 0);\n   num_live_replicas_ = req->num_live_tablets();\n   leader_count_ = req->leader_count();\n   physical_time_ = req->ts_physical_time();","new":" }\n void TSDescriptor::UpdateHeartbeat(const TSHeartbeatRequestPB* req) {\n   DCHECK_GE(req->num_live_tablets(), 0);\n   DCHECK_GE(req->leader_count(), 0);\n+  std::lock_guard<decltype(lock_)> l(lock_);\n+  last_heartbeat_ = MonoTime::Now();\n   num_live_replicas_ = req->num_live_tablets();\n   leader_count_ = req->leader_count();\n   physical_time_ = req->ts_physical_time();","review":"It seems these two checks can be lifted ahead of taking the lock","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3,4,5],"loc_wrong_easy":[[1,2,3],[1,4,6],[1,5,7]],"loc_wrong_hard":[[1,3,4],[1,3,5],[1,4,5]]}
{"old":"     \/* Store public key at cert_chain to cut down expensive use of s2n_asn1der_to_public_key_and_type *\/\n     chain_and_key->cert_chain->head->public_key = public_key;\n     \/* Populate name information from the SAN\/CN for the leaf certificate *\/\n     POSIX_GUARD(s2n_cert_chain_and_key_set_names(chain_and_key, &chain_and_key->cert_chain->head->raw));\n-    ZERO_TO_DISABLE_DEFER_CLEANUP(public_key);\n     return 0;\n }","new":"     \/* Store public key at cert_chain to cut down expensive use of s2n_asn1der_to_public_key_and_type *\/\n     chain_and_key->cert_chain->head->public_key = public_key;\n+    ZERO_TO_DISABLE_DEFER_CLEANUP(public_key);\n     \/* Populate name information from the SAN\/CN for the leaf certificate *\/\n     POSIX_GUARD(s2n_cert_chain_and_key_set_names(chain_and_key, &chain_and_key->cert_chain->head->raw));\n     return 0;\n }","review":"What if line 4 fails? Shouldn't you ZERO_TO_DISABLE_DEFER_CLEANUP immediately before\/after line 3?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[5],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"     RESULT_ENSURE_LTE(digest_length, data_len);\n-    RESULT_CHECKED_MEMCPY(data, digest_data, data_len);\n     return S2N_RESULT_OK;\n }","new":"     RESULT_ENSURE_LTE(digest_length, data_len);\n+    RESULT_CHECKED_MEMCPY(data, digest_data, digest_length);\n     return S2N_RESULT_OK;\n }","review":"Should be `digest_length` otherwise by providing a large buffer the code will cause ub.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[2],"loc_wrong_easy":[[1],[3],[4]],"loc_wrong_hard":[[1],[3],[4]]}
{"old":" #include <errno.h>\n #include <s2n.h>\n-#define PSK_SECRET_SIZE_MAX 2048\n char *load_file_to_cstring(const char *path)\n {\n     FILE *pem_file = fopen(path, \"rb\");","new":" #include <errno.h>\n #include <s2n.h>\n char *load_file_to_cstring(const char *path)\n {\n     FILE *pem_file = fopen(path, \"rb\");","review":"Why do we need a limit on secret size? Are we advertising it somewhere?","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":" #include <stdlib.h>\n #include <limits.h>\n-#ifndef _MSC_VER\n-#define MAY_HAVE_FTRUNCATE\n-#include <unistd.h>\n-#endif\n-\n #ifdef READTAGS_DSL\n #define xMalloc(n,Type)    (Type *)eMalloc((size_t)(n) * sizeof (Type))\n #define xRealloc(p,n,Type) (Type *)eRealloc((p), (n) * sizeof (Type))","new":" #include <stdlib.h>\n #include <limits.h>\n #ifdef READTAGS_DSL\n #define xMalloc(n,Type)    (Type *)eMalloc((size_t)(n) * sizeof (Type))\n #define xRealloc(p,n,Type) (Type *)eRealloc((p), (n) * sizeof (Type))","review":"Isn't this line redundant? If `WIN32` isn't defined, `_MSC_VER` won't be defined.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[3,4,5,6,7],"loc_wrong_easy":[[1,2,3,4,5],[1,2,3,6,7],[1,2,3,8,9]],"loc_wrong_hard":[[1,3,4,5,6],[1,3,4,5,7],[1,3,4,6,7]]}
{"old":"     }\n     memset(&listener->ssl, 0, sizeof(listener->ssl));\n     memset(&listener->quic, 0, sizeof(listener->quic));\n-\n-#if defined(__linux__)\n-    listener->timestamping = timestamping;\n-#else \/* !defined(__linux__) *\/\n-    listener->timestamping = 0;\n-#endif \/* defined(__linux__) *\/\n-\n     listener->quic.qpack = (h2o_http3_qpack_context_t){.encoder_table_capacity = 4096 \/* our default *\/};\n     listener->proxy_protocol = proxy_protocol;\n     listener->tcp_congestion_controller = h2o_iovec_init(NULL, 0);","new":"     }\n     memset(&listener->ssl, 0, sizeof(listener->ssl));\n     memset(&listener->quic, 0, sizeof(listener->quic));\n+listener->timestamping = timestamping;\n     listener->quic.qpack = (h2o_http3_qpack_context_t){.encoder_table_capacity = 4096 \/* our default *\/};\n     listener->proxy_protocol = proxy_protocol;\n     listener->tcp_congestion_controller = h2o_iovec_init(NULL, 0);","review":" I think we'd want to be principled if the concept of timestamping is platform-agnostic or not. If it is going to be platform-specific, not only these lines but everything (incl. `listener_config_t::timestamping`, `timestamping` argument passed to `add_listener`) have to be covered by `#if defined(__linux__)`. If we are to consider timestamping as a platform-agnostic concept that happens to be supported only on some platforms at the moment, I think we'd not want to change the flag silently at the middle between where the flag is set (i.e. config knob) and where the flag is used.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4,5,6,7,8,9,10],"loc_wrong_easy":[[1,2,3,4,5,6,7],[1,2,3,4,8,9,10],[1,2,3,4,11,12,13]],"loc_wrong_hard":[[1,4,5,6,7,8,9],[1,4,5,6,7,8,10],[1,4,5,6,7,9,10]]}
{"old":"     return S2N_SUCCESS;\n }\n-int s2n_cert_get_cert_der(const struct s2n_cert *cert, const uint8_t **out_cert_der, uint32_t *cert_length)\n {\n     POSIX_ENSURE_REF(cert);\n     POSIX_ENSURE_REF(out_cert_der);","new":"     return S2N_SUCCESS;\n }\n+int s2n_cert_get_der(const struct s2n_cert *cert, const uint8_t **out_cert_der, uint32_t *cert_length)\n {\n     POSIX_ENSURE_REF(cert);\n     POSIX_ENSURE_REF(out_cert_der);","review":"For all your \"cert_get_cert\" -- maybe drop the second \"cert\"? So for example, \"s2n_cert_get_der\" instead of \"s2n_cert_get_cert_der\"","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":" \/* UDP multicast network layer specific internal data *\/\n typedef struct {\n     int ai_family;                    \/* Protocol family for socket. IPv4\/IPv6 *\/\n-    struct sockaddr_storage *ai_addr; \/* https:\/\/msdn.microsoft.com\/de-de\/library\/windows\/desktop\/ms740496(v=vs.85).aspx *\/\n-    struct sockaddr_storage *intf_addr;\n     UA_UInt32 messageTTL;\n     UA_Boolean enableLoopback;\n     UA_Boolean enableReuse;","new":" \/* UDP multicast network layer specific internal data *\/\n typedef struct {\n     int ai_family;                    \/* Protocol family for socket. IPv4\/IPv6 *\/\n+    struct sockaddr_storage ai_addr; \/* https:\/\/msdn.microsoft.com\/de-de\/library\/windows\/desktop\/ms740496(v=vs.85).aspx *\/\n+    struct sockaddr_storage intf_addr;\n     UA_UInt32 messageTTL;\n     UA_Boolean enableLoopback;\n     UA_Boolean enableReuse;","review":"I would prefer if both `sockaddr_storage` were not pointers but direct members. That removes a lot of the allocation and cleanup logic.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4,5],"loc_wrong_easy":[[1,2],[3,6],[8,7]],"loc_wrong_hard":[[1,4],[1,5],[2,4]]}
{"old":"             c, \"paths\", H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING | H2O_CONFIGURATOR_FLAG_DEFERRED,\n             on_config_paths);\n         h2o_configurator_define_command(\n-            c, \"strict-match\", H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR | H2O_CONFIGURATOR_FLAG_DEFERRED,\n             on_config_strict_match);\n     };","new":"             c, \"paths\", H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING | H2O_CONFIGURATOR_FLAG_DEFERRED,\n             on_config_paths);\n         h2o_configurator_define_command(\n+            c, \"strict-match\", H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,\n             on_config_strict_match);\n     };","review":" I do not think this directive has to be merged deferred, as it does not depend on other directives used at global- or host-level?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"     struct st_h2o_http3_server_conn_t *conn = get_conn(stream);\n     if (stream->tunnel->datagram_flow_id != UINT64_MAX) {\n         khiter_t iter = kh_get(stream, conn->datagram_flows, stream->tunnel->datagram_flow_id);\n-        \/* the tunnel wasn't established yet *\/\n-        if (iter == kh_end(conn->datagram_flows))\n-            return;\n-        kh_del(stream, conn->datagram_flows, iter);\n     }\n }","new":"     struct st_h2o_http3_server_conn_t *conn = get_conn(stream);\n     if (stream->tunnel->datagram_flow_id != UINT64_MAX) {\n         khiter_t iter = kh_get(stream, conn->datagram_flows, stream->tunnel->datagram_flow_id);\n+        \/* it's possible the tunnel wasn't established yet *\/\n+        if (iter != kh_end(conn->datagram_flows))\n+            kh_del(stream, conn->datagram_flows, iter);\n     }\n }","review":"I wonder if we should avoid early return here. The rationale is that the function is expected to dispose all the properties, where `datagram_flow_id` is just one among them. Therefore, I tend to believe that a statement (or a block) that disposes each element should not do an early return, and that applies to the last property as well for the sake of consistency.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4,5,6,7],"loc_wrong_easy":[[1,2,3,4],[1,2,5,6],[8,1,2,7]],"loc_wrong_hard":[[1,4,5,6],[1,4,5,7],[1,4,6,7]]}
{"old":" namespace {\n bool CompareByHost(const TabletReplica& a, const TabletReplica& b) {\n-    TSRegistrationPB reg_a = a.ts_desc->GetRegistration();\n-    TSRegistrationPB reg_b = b.ts_desc->GetRegistration();\n-    if (!reg_a.common().http_addresses().empty() && !reg_b.common().http_addresses().empty()) {\n-        return reg_a.common().http_addresses(0).host() < reg_b.common().http_addresses(0).host();\n-    } else {\n-        return a.ts_desc->permanent_uuid() < b.ts_desc->permanent_uuid();\n-    }\n }\n } \/\/ anonymous namespace","new":" namespace {\n bool CompareByHost(const TabletReplica& a, const TabletReplica& b) {\n+    return a.ts_desc->permanent_uuid() < b.ts_desc->permanent_uuid();\n }\n } \/\/ anonymous namespace","review":"since permanent_uuid is generally expected to not be empty, and since our goal is only to have \/some\/ stable sorting of hosts, why dont we simplify this logic by always sorting by permanent_uuid?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3,4,5,6,7,8,9],"loc_wrong_easy":[[1,2,3,4,5,6,7],[1,2,3,4,5,8,9],[1,2,3,4,5,10,11]],"loc_wrong_hard":[[1,3,4,5,6,7,8],[1,3,4,5,6,7,9],[1,3,4,5,6,8,9]]}
{"old":" {\n     S2N_ERROR_IF(initialized == false, S2N_ERR_NOT_INITIALIZED);\n     notnull_check(b);\n-    POSIX_ENSURE(b->size == 0, S2N_ERR_ALLOC);\n     const struct s2n_blob temp = {0};\n     *b = temp;\n     GUARD(s2n_realloc(b, size));","new":" {\n     S2N_ERROR_IF(initialized == false, S2N_ERR_NOT_INITIALIZED);\n     notnull_check(b);\n+    POSIX_ENSURE(b->allocated == 0, S2N_ERR_ALLOC);\n     const struct s2n_blob temp = {0};\n     *b = temp;\n     GUARD(s2n_realloc(b, size));","review":"Shouldn't you be checking b->allocated instead of b->size?","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[4],"loc_wrong_easy":[[1],[2],[3]],"loc_wrong_hard":[[1],[2],[3]]}
{"old":"   auto status = active_segment_->WriteFooterAndClose(footer_builder_);\n   if (status.ok() && metrics_) {\n-      metrics_->wal_size->IncrementBy(active_segment_->written_offset());\n   } \n   return status;\n }","new":"   auto status = active_segment_->WriteFooterAndClose(footer_builder_);\n   if (status.ok() && metrics_) {\n+      metrics_->wal_size->IncrementBy(active_segment_->Size());\n   } \n   return status;\n }","review":"Lets use the Size() function.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"     GUARD_PTR(s2n_blob_zero(&mem));\n     struct s2n_offered_psk *psk = (struct s2n_offered_psk*)(void*) mem.data;\n-    *psk = (struct s2n_offered_psk){ 0 };\n     ZERO_TO_DISABLE_DEFER_CLEANUP(mem);\n     return psk;","new":"     GUARD_PTR(s2n_blob_zero(&mem));\n     struct s2n_offered_psk *psk = (struct s2n_offered_psk*)(void*) mem.data;\n     ZERO_TO_DISABLE_DEFER_CLEANUP(mem);\n     return psk;","review":"You don't need to do \"*psk = (struct s2n_offered_psk){ 0 };\" anymore. You've already zeroed the memory.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"                       \"Number of bytes logged since service start\");\n METRIC_DEFINE_counter(tablet, log_wal_size, \"Size of WAL Files\",\n-                      yb::MetricUnit::kUnits,\n                       \"Size of wal files\");\n METRIC_DEFINE_histogram(tablet, log_sync_latency, \"Log Sync Latency\",","new":"                       \"Number of bytes logged since service start\");\n METRIC_DEFINE_counter(tablet, log_wal_size, \"Size of WAL Files\",\n+                      yb::MetricUnit::kBytes,\n                       \"Size of wal files\");\n METRIC_DEFINE_histogram(tablet, log_sync_latency, \"Log Sync Latency\",","review":"Lets make the units kBytes.","type_correct":"modify","type_wrong":["add_only","remove_only"],"loc_correct":[3],"loc_wrong_easy":[[1],[2],[4]],"loc_wrong_hard":[[1],[2],[4]]}
{"old":"         const uint8_t *ours = security_policy->cipher_preferences->suites[i]->iana_value;\n         if (memcmp(wire, ours, S2N_TLS_CIPHER_SUITE_LEN) == 0) {\n             cipher_suite = security_policy->cipher_preferences->suites[i];\n         }\n     }\n     ENSURE_POSIX(cipher_suite != NULL, S2N_ERR_CIPHER_NOT_SUPPORTED);","new":"         const uint8_t *ours = security_policy->cipher_preferences->suites[i]->iana_value;\n         if (memcmp(wire, ours, S2N_TLS_CIPHER_SUITE_LEN) == 0) {\n             cipher_suite = security_policy->cipher_preferences->suites[i];\n+            break;\n         }\n     }\n     ENSURE_POSIX(cipher_suite != NULL, S2N_ERR_CIPHER_NOT_SUPPORTED);","review":"Should we short-circuit on a match rather than always searching every case in a policy?","type_correct":"add_only","type_wrong":["remove_only","modify"],"loc_correct":[3],"loc_wrong_easy":[[0],[1],[2]],"loc_wrong_hard":[[0],[1],[2]]}
{"old":"          * extra file descriptor, the poll(2) call is straightforward\n          * for this use case.\n          *\/\n-        FD_ZERO(&wait_set);\n-        FD_SET(fd, &wait_set);\n         pfd_read.fd = fd + 1;\n         pfd_read.events = POLLIN;","new":"          * extra file descriptor, the poll(2) call is straightforward\n          * for this use case.\n          *\/\n         pfd_read.fd = fd + 1;\n         pfd_read.events = POLLIN;","review":"Now variable `fd_set wait_set`, FD_ZERO and FD_SET are useless.","type_correct":"remove_only","type_wrong":["add_only","modify"],"loc_correct":[4,5],"loc_wrong_easy":[[1,2],[1,3],[1,4]],"loc_wrong_hard":[[1,4],[1,5],[2,4]]}
